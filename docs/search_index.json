[
["index.html", "Hands-On Spatial Data Science with R Introduction Disclaimer Using This Book Who This Book Is For", " Hands-On Spatial Data Science with R Luc Anselin, Grant Morrison, Angela Li, Karina Acosta 2020-07-02 Introduction This book contains the R version of the GeoDa Workbook developed by Luc Anselin. It accompanies the Introduction to Spatial Data Science course taught at the University of Chicago. Each chapter was originally developed as a standalone lab tutorial for one week of the class. As a result, it is possible to work through a single chapter on its own, though we recommend going from the beginning to the end. Disclaimer This book is still actively under development and may not work for you when you access it. For versions of the lab notebooks that have been tested and are not undergoing changes, please see the Tutorials page on our Spatial Analysis with R website. Using This Book We have developed an R data package (geodaData) to use along with this book, so you can work through through the exercises immediately. To install it, run the following in your R console: # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;spatialanalysis/geodaData&quot;) Who This Book Is For We assume that workshop attendees have used RStudio and are familiar with the basics of R. If you need a refresher, this R for Social Scientists tutorial developed by Data Carpentry is a good place to start. Additionally, Luc Anselin's introductory R lab notes can be found on the CSDS Tutorials page. During Fall Quarter 2019, Angela Li will be teaching from sections of this book during the R Spatial Workshop. If you have any questions about the following material, please reach out to her at ali6@uchicago.edu. This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],
["spatial-data-handling.html", "Chapter 1 Spatial Data Handling Introduction Preliminaries Obtaining data from the Chicago Open Data portal Selecting Observations for a Given Time Period Creating a Point Layer Abandoned Vehicles by Community Area Community Area Population Data Mapping Community Area Abandoned Vehicles Per Capita", " Chapter 1 Spatial Data Handling Introduction This R notebook covers the functionality of the Spatial Data Handling section of the GeoDa workbook. We refer to that document for details on the methodology, references, etc. The goal of these notes is to approximate as closely as possible the operations carried out using GeoDa by means of a range of R packages. The notes are written with R beginners in mind, more seasoned R users can probably skip most of the comments on data structures and other R particulars. Also, as always in R, there are typically several ways to achieve a specific objective, so what is shown here is just one way that works, but there often are others (that may even be more elegant, work faster, or scale better). In this lab, we will use the City of Chicago open data portal to download data on abandoned vehicles. Our end goal is to create a choropleth map with abandoned vehicles per capita for Chicago community areas. Before we can create the maps, we will need to download the information, select observations, aggregate data, join different files and carry out variable transformations in order to obtain a so-called “spatially intensive” variable for mapping (i.e., not just a count of abandoned vehicles, but a per capita ratio). Objectives After completing the notebook, you should know how to carry out the following tasks: Download data from any Socrata-driven open data portal, such as the City of Chicago open data portal Filtering a data frame for specific entries Selecting and renaming columns Creating a simple features spatial object Checking and adding/adjusting projection information Dealing with missing data Spatial join Spatial aggregation Parsing a pdf file Merging data sets Creating new variables Basic choropleth mapping R Packages used RSocrata: to read data directly from a Socrata powered open data portal, such as the Chicago open data portal tidyverse (includes dplyr): to manipulate data frames, such as filtering data, selecting columns, and creating new variables lubridate: to select information out of the date format when filtering the data sf: to create and manipulate simple features spatial objects, to read in the boundary file, and perform point in polygon on the data set to fill in missing community area information pdftools: to read and parse a pdf for chicago community area population information tmap: to make nice looking choropleth maps R Commands used Below follows a list of the commands used in this notebook. For further details and a comprehensive list of options, please consult the R documentation. base R: setwd, install.packages, library, head, dim, class, as.Date, names, !is.na, is.numeric, as.integer, is.integer, length, strsplit, unlist, for, vector, substr, gsub, as.numeric, data.frame RSocrata: read.socrata tidyverse: filter, %&gt;% (pipe), select (with renaming), count, rename, mutate lubridate: year, month sf: st_as_sf, plot, st_crs, read_sf, st_transform, st_join, st_geometry, st_write pdftools: pdf_text tmap: tm_shape, tm_polygons Preliminaries Before starting, make sure to have the latest version of R and of packages that are compiled for the matching version of R (this document was created using R 3.5.1 of 2018-07-02). Also, optionally, set a working directory, even though we will not actually be saving any files.1 Loading packages First, we load all the required packages using the library command. If you don't have some of these in your system, make sure to install them first as well as their dependencies.2 You will get an error message if something is missing. If needed, just install the missing piece and everything will work after that. library(tidyverse) ## ── Attaching packages ───────────────────────────── tidyverse 1.2.1 ── ## ✓ ggplot2 3.3.0 ✓ purrr 0.3.4 ## ✓ tibble 3.0.1 ✓ dplyr 0.8.5 ## ✓ tidyr 1.0.3 ✓ stringr 1.4.0 ## ✓ readr 1.3.1 ✓ forcats 0.4.0 ## Warning: package &#39;tibble&#39; was built under R version 3.6.2 ## Warning: package &#39;tidyr&#39; was built under R version 3.6.2 ## Warning: package &#39;purrr&#39; was built under R version 3.6.2 ## ── Conflicts ──────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(lubridate) ## Warning: package &#39;lubridate&#39; was built under R version 3.6.2 ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## intersect, setdiff, union ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union library(sf) ## Linking to GEOS 3.7.2, GDAL 2.4.2, PROJ 5.2.0 library(tmap) library(pdftools) ## Warning: package &#39;pdftools&#39; was built under R version 3.6.2 ## Using poppler version 0.73.0 library(RSocrata) Obtaining data from the Chicago Open Data portal We will use the specialized RSocrata package to download the file with 311 calls about abandoned vehicles from the City of Chicago open data portal. A list of different types of 311 nuisance calls is given by selecting the button for Service Requests. The abandoned vehicles data are contained in the entry for 311 Service Requests - Abandoned Vehicles. Select the API button and copy the API Endpoint from the interface. This is the target file that we will download using the read.socrata function from the RSocrata package. Note, this is a large file, so it may take a while to download. First, we set the target file name to pass to the read.socrata function. Copy the API Endpoint and paste the file path, as shown below. socrata.file &lt;- &quot;https://data.cityofchicago.org/resource/suj7-cg3j.csv&quot; Next, download the file using read.socrata. This will turn the data into an R data frame. After the download is completed, we use the head command to get a sense of the contents of the data frame. vehicle.data &lt;- read.socrata(socrata.file) head(vehicle.data) ## creation_date status completion_date service_request_number ## 1 2011-01-01 Completed - Dup 2011-01-07 11-00002779 ## 2 2011-01-01 Completed - Dup 2011-01-20 11-00003001 ## 3 2011-01-01 Completed - Dup 2011-01-21 11-00003309 ## 4 2011-01-01 Completed - Dup 2011-01-21 11-00003316 ## 5 2011-01-01 Completed 2011-01-05 11-00001976 ## 6 2011-01-01 Completed 2011-01-05 11-00002291 ## type_of_service_request ## 1 Abandoned Vehicle Complaint ## 2 Abandoned Vehicle Complaint ## 3 Abandoned Vehicle Complaint ## 4 Abandoned Vehicle Complaint ## 5 Abandoned Vehicle Complaint ## 6 Abandoned Vehicle Complaint ## license_plate vehicle_make_model ## 1 REAR PLATE STARTS W/848 AND FRONT PLATE STARTS W/ K Isuzu ## 2 9381880 Toyota ## 3 MI S CS860 Jeep/Cherokee ## 4 MI SCS860 ## 5 H924236 Ford ## 6 810 LYB WISCONSIN PLATES Mercury ## vehicle_color current_activity most_recent_action ## 1 Red ## 2 Silver ## 3 Gold ## 4 Gold ## 5 White ## 6 Green ## how_many_days_has_the_vehicle_been_reported_as_parked_ street_address ## 1 24 5629 N KEDVALE AVE ## 2 NA 2053 N KILBOURN AVE ## 3 NA 736 W BUENA AVE ## 4 NA 736 W BUENA AVE ## 5 60 6059 S KOMENSKY AVE ## 6 NA 4651 S WASHTENAW AVE ## zip_code x_coordinate y_coordinate ward police_district community_area ssa ## 1 60646 1147717 1937054 39 17 13 NA ## 2 60639 1146056 1913269 31 25 20 NA ## 3 60613 1170576 1928214 46 23 3 NA ## 4 60613 1170576 1928214 46 23 3 NA ## 5 60629 1150408 1864110 13 8 65 3 ## 6 60632 1159150 1873712 12 9 58 NA ## latitude longitude location ## 1 41.98368 -87.73197 POINT (41.983680361597564 -87.7319663736746) ## 2 41.91859 -87.73868 POINT (41.91858774162382 -87.73868431751842) ## 3 41.95861 -87.64888 POINT (41.95860696269331 -87.64887590959788) ## 4 41.95861 -87.64888 POINT (41.95860696269331 -87.64887590959788) ## 5 41.78237 -87.72394 POINT (41.78237428405976 -87.72394038021173) ## 6 41.80864 -87.69163 POINT (41.80863500843091 -87.69162625248853) ## location_address location_city location_state location_zip ## 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 6 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; A quick glance at the table reveals quite a bit of missing information, something we will have to deal with. We also check the dimension of this data frame using the dim command: dim(vehicle.data) ## [1] 258700 26 The table has 203,657 observations on 26 variables (the number of observations shown may be slightly different as the table is constantly updated). In RStudio, the type of the variable in each column is listed under its name. For example, under creation_date, we see S3: POSIXct. You can also find out the same information by applying a class command to the variable vehicle.data$creation_date, as in class(vehicle.data$creation_date) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; The result again yields POSIXct, which is a common format used for dates. Note that RSocrata is able to tell the date format from a simple string. In contrast, if we had downloaded the file manually as a csv (comma separated value) file, this would not be the case (see the GeoDa example). In that instance, we would have to convert the creation_date to a date format explicitly using as.Date. Selecting Observations for a Given Time Period As in the GeoDa example, we are not using all the data, but will analyze the abandoned vehicle locations for a given time period, i.e., the month of September 2016. Extracting observations for the desired time period To extract the observations for the selected year (2016) and month (9), we will use the year and month functions from the lubridate package. We will embed these expressions in a filter command (from tidyverse) to select the rows/observations that match the specified criterion. We will also use the pipe command %&gt;% to move the original data frame through the different filter stages and assign the end result to vehicle.sept16. We again check the contents with a head command. vehicle.sept16 &lt;- vehicle.data %&gt;% filter(year(creation_date) == 2016) %&gt;% filter(month(creation_date) == 9) head(vehicle.sept16) ## creation_date status completion_date service_request_number ## 1 2016-09-01 Completed - Dup 2016-09-01 16-06192603 ## 2 2016-09-01 Completed - Dup 2016-09-01 16-06192662 ## 3 2016-09-01 Completed - Dup 2016-09-01 16-06193608 ## 4 2016-09-01 Completed - Dup 2016-09-01 16-06194284 ## 5 2016-09-01 Completed - Dup 2016-09-01 16-06194594 ## 6 2016-09-01 Completed - Dup 2016-09-01 16-06197569 ## type_of_service_request license_plate vehicle_make_model vehicle_color ## 1 Abandoned Vehicle Complaint UNKNOWN Chevrolet White ## 2 Abandoned Vehicle Complaint UNKNOWN Green ## 3 Abandoned Vehicle Complaint UKNOWN Gray ## 4 Abandoned Vehicle Complaint NO PLATES Ford Blue ## 5 Abandoned Vehicle Complaint ## 6 Abandoned Vehicle Complaint ## current_activity most_recent_action ## 1 FVI - Outcome Create Work Order ## 2 FVI - Outcome Create Work Order ## 3 FVI - Outcome Create Work Order ## 4 FVI - Outcome Create Work Order ## 5 FVI - Outcome Create Work Order ## 6 FVI - Outcome Create Work Order ## how_many_days_has_the_vehicle_been_reported_as_parked_ street_address ## 1 14 3710 W IOWA ST ## 2 40 5240 S MAYFIELD AVE ## 3 7 8000 S ALBANY AVE ## 4 30 8654 W CATHERINE AVE ## 5 NA 4315 N MONTICELLO AVE ## 6 NA 2241 N MULLIGAN AVE ## zip_code x_coordinate y_coordinate ward police_district community_area ssa ## 1 60651 1151452 1905748 27 11 23 NA ## 2 60638 1137921 1869254 14 8 56 NA ## 3 60652 1157102 1851405 18 8 70 NA ## 4 60656 1117638 1934535 41 16 76 NA ## 5 60618 1151283 1928434 35 17 16 NA ## 6 60639 1133710 1914324 36 25 19 NA ## latitude longitude location ## 1 41.89736 -87.71933 POINT (41.89736153676566 -87.71933325878982) ## 2 41.79688 -87.76990 POINT (41.796881421903066 -87.76989633815052) ## 3 41.74792 -87.70005 POINT (41.74792366108626 -87.70004701460941) ## 4 41.97694 -87.84349 POINT (41.97694235046974 -87.8434945723464) ## 5 41.95972 -87.71907 POINT (41.95972327912134 -87.71906810908936) ## 6 41.92154 -87.78402 POINT (41.92154133910697 -87.78401648793171) ## location_address location_city location_state location_zip ## 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 6 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; and the dimension: dim(vehicle.sept16) ## [1] 2637 26 The filtered table now only has 2,637 observations. Selecting the variables for the final table The current data frame contains 26 variables. Several of these are not really of interest to us, since we basically want the locations of the events. We will use the select command from tidyverse to pick out the columns that we want to keep. In addition, we will use the rename option in select to give new variable names. While this is not absolutely necessary at this stage (RSocrata has turned any weird variable names into proper R names), we may later want to save the data as a point shape file. The data associated with a shape file are store in a separate dBase file, and dBase only allows 10 characters for variable names. So, in order to save ourselves some work later on, we will rename the selected variables to strings that do not exceed 10 characters. First, we check the variable names using the names command. names(vehicle.sept16) ## [1] &quot;creation_date&quot; ## [2] &quot;status&quot; ## [3] &quot;completion_date&quot; ## [4] &quot;service_request_number&quot; ## [5] &quot;type_of_service_request&quot; ## [6] &quot;license_plate&quot; ## [7] &quot;vehicle_make_model&quot; ## [8] &quot;vehicle_color&quot; ## [9] &quot;current_activity&quot; ## [10] &quot;most_recent_action&quot; ## [11] &quot;how_many_days_has_the_vehicle_been_reported_as_parked_&quot; ## [12] &quot;street_address&quot; ## [13] &quot;zip_code&quot; ## [14] &quot;x_coordinate&quot; ## [15] &quot;y_coordinate&quot; ## [16] &quot;ward&quot; ## [17] &quot;police_district&quot; ## [18] &quot;community_area&quot; ## [19] &quot;ssa&quot; ## [20] &quot;latitude&quot; ## [21] &quot;longitude&quot; ## [22] &quot;location&quot; ## [23] &quot;location_address&quot; ## [24] &quot;location_city&quot; ## [25] &quot;location_state&quot; ## [26] &quot;location_zip&quot; To keep things simple, we will only keep community_area, latitude and longitude, and turn them into comm, lat and lon. The new data set is vehicles.final. Note that to rename a variable, the new name is listed first, on the left hand side of the equal sign, and the old name is on the right hand side. We check the result with the head command. vehicles.final &lt;- vehicle.sept16 %&gt;% select(comm = community_area, lat = latitude, lon = longitude) head(vehicles.final) ## comm lat lon ## 1 23 41.89736 -87.71933 ## 2 56 41.79688 -87.76990 ## 3 70 41.74792 -87.70005 ## 4 76 41.97694 -87.84349 ## 5 16 41.95972 -87.71907 ## 6 19 41.92154 -87.78402 Creating a Point Layer So far, we have only dealt with a regular data frame, without taking advantage of any spatial features. However, the data frame contains fields with coordinates and R can turn these into an explicit spatial points layer that can be saved in a range of GIS formats. To accomplish this, we will use the (new) simple features or sf package functionality, which improves upon the older sp. We will first use the lat and lon columns in the data frame to create a spatial points object. Note that lon is the x-coordinate and lat is the y-coordinate. Creating a point layer from coordinates in a table - principle In sf, a simple features object is constructed by combining a geometry with the actual data (in a data frame). However, this is simplified for point objects when the data frame contains the coordinates as variables. This is the case in our example, where we have latitude and longitude. We also have x and y, but since we are not sure what projection these coordinates correspond with, they are not useful at this stage. The advantage of lat-lon is that they are decimal degrees, and thus unprojected. However, we can provide the information on the datum, typically WGS84 (the standard used in most applications for decimal degrees) by passing the coordinate reference system argument (crs) set to the EPSG code 4326. After that, we can use the built-in projection transformation functionality in sf to turn the points into any projection we want.3 Missing coordinates In order to create a points layer, we need coordinates for every observation. However, as we can see from the head command above, there are (at least) two observations that do not have lat-lon information. Before we can proceed, we need to remove these from the data frame. We again use a filter command, but now combine it with the !is.na expression, i.e., is not missing (na). We take a little short cut by assuming that if one of lat or lon is missing, the other one will be missing as well (although to keep it completely general, we would need to check each variable separately). We assign the result to the vehicle.coord data frame. vehicle.coord &lt;- vehicles.final %&gt;% filter(!(is.na(lat))) dim(vehicle.coord) ## [1] 2635 3 As it turns out, the two rows we noticed above were the only two with missing coordinates (the number of rows went from 2,637 to 2,635). Creating a spatial points object The sf package turns a non-spatial object like a data frame into a simple features spatial object by means of the st_as_sf function. This function can take a large number of arguments, but for now we will only use a few: the name of the data frame, i.e., vehicle.coord coords: the variable names for x and y (given in parentheses) crs: the coordinate reference system, here using the EPSG code of 4326 agr: the so-called attibute-geometry-relationship which specifies how the attribute information (the data) relate to the geometry (the points); in our example, we will use &quot;constant&quot; In our example, we create vehicle.points and check its class. vehicle.points = st_as_sf(vehicle.coord, coords = c(&quot;lon&quot;, &quot;lat&quot;), crs = 4326, agr = &quot;constant&quot;) class(vehicle.points) ## [1] &quot;sf&quot; &quot;data.frame&quot; Even though it is not that informative at this stage, we can also make a quick plot. Later, we will see how we can refine these plots using the tmap package. plot(vehicle.points) We can also do a quick check of the projection information using the st_crs command. st_crs(vehicle.points) ## Coordinate Reference System: ## EPSG: 4326 ## proj4string: &quot;+proj=longlat +datum=WGS84 +no_defs&quot; The proj4string is a slightly more informative description than the simple EPSG code and confirms the data are not projected (longlat) using the WGS84 datum for the decimal degree coordinates. Abandoned Vehicles by Community Area At this point, we will go about things in a slightly different way from how they are illustrated in the GeoDa workbook example. As it turns out, some of the points have missing community area information, which is a critical element to compute the number of abandoned cars at that scale. In GeoDa, we used a visual approach to obtain the missing information. Here, we will exploit some of the GIS functionality in sf to carry out a spatial join. This boils down to identifying which points belong to each community area (a so-called point in polygon query) and assigning the corresponding community area identifier to each point. We proceed in three steps. First, we create a simple features spatial polygon object with the boundaries of the community areas, which we download from the Chicago Open Data portal. Next, we carry out a spatial join between our points object and the polygon object to assign a community area code to each point. Finally, we compute the point count by community area. Community Area boundary file We resort to the City of Chicago open data portal for the boundary file of the community areas. From the opening screen, select the button for Facilities &amp; Geo Boundaries. This yields a list of different boundary files for a range of geographic areal units. The one for the community areas is Boundaries - Community Areas (current). This brings up an overview map of the geography of the community areas of Chicago. Of course, we could simply select one of the export buttons to download the files, but we want to do this programmatically. As it turns out, sf can read a geojson formatted file directly from the web, and we will exploit that functionality. First, we need the name for the file. We can check the Socrata API file name, but that contains a json file, and we want a specific geojson file. As it turns out, the latter is simply the same file name, but with the geojson file extension. We set our variable comm.file to this URL and then use sf_read to load the boundary information into chicago.comm. As before, we can do a quick check of the class using the class command. comm.file &lt;- &quot;https://data.cityofchicago.org/resource/igwz-8jzy.geojson&quot; chicago.comm &lt;- read_sf(comm.file) class(chicago.comm) ## [1] &quot;sf&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; In addition, we check the projection information using st_crs. st_crs(chicago.comm) ## Coordinate Reference System: ## EPSG: 4326 ## proj4string: &quot;+proj=longlat +datum=WGS84 +no_defs&quot; Again, the layer is unprojected in decimal degrees. Also, a quick plot. Note that, by default, sf draws a choropleth map for each variable included in the data frame. Since we won't be using sf for mapping, we ignore that aspect for now. plot(chicago.comm) We also use head to check on the types of the variables. head(chicago.comm) ## Simple feature collection with 6 features and 9 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -87.7069 ymin: 41.79448 xmax: -87.58001 ymax: 41.99076 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## # A tibble: 6 x 10 ## community area shape_area perimeter area_num_1 area_numbe comarea_id comarea ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 DOUGLAS 0 46004621.… 0 35 35 0 0 ## 2 OAKLAND 0 16913961.… 0 36 36 0 0 ## 3 FULLER P… 0 19916704.… 0 37 37 0 0 ## 4 GRAND BO… 0 48492503.… 0 38 38 0 0 ## 5 KENWOOD 0 29071741.… 0 39 39 0 0 ## 6 LINCOLN … 0 71352328.… 0 4 4 0 0 ## # … with 2 more variables: shape_len &lt;chr&gt;, geometry &lt;MULTIPOLYGON [°]&gt; Changing projections Before moving on to the spatial join operation, we will convert both the community area boundaries and the vehicle points to the same projection, using the st_transform command. We assign the UTM (Universal Tranverse Mercator) zone 16N, which the the proper one for Chicago, with an EPSG code of 32616. After the projection transformation, we check the result using st_crs. chicago.comm &lt;- st_transform(chicago.comm,32616) st_crs(chicago.comm) ## Coordinate Reference System: ## EPSG: 32616 ## proj4string: &quot;+proj=utm +zone=16 +datum=WGS84 +units=m +no_defs&quot; vehicle.points &lt;- st_transform(vehicle.points,32616) st_crs(vehicle.points) ## Coordinate Reference System: ## EPSG: 32616 ## proj4string: &quot;+proj=utm +zone=16 +datum=WGS84 +units=m +no_defs&quot; Spatial join In essence, the spatial join operation finds the polygon to which each point belongs. Several points belong to the same polygon, so this is a many-to-one join. Instead of joining all the features of the polygon layer, we specify just area_num_1, which is the community area indicator. The command is st_join to which we pass the point layer as the first sf object, and the polygon layer as the second sf object (with only one column designated). We assign the result to the new spatial object comm.pts. We check the contents of the new object using a head command. comm.pts &lt;- st_join(vehicle.points,chicago.comm[&quot;area_num_1&quot;]) head(comm.pts) ## Simple feature collection with 6 features and 2 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 430118.3 ymin: 4622026 xmax: 441795.4 ymax: 4647560 ## epsg (SRID): 32616 ## proj4string: +proj=utm +zone=16 +datum=WGS84 +units=m +no_defs ## comm area_num_1 geometry ## 1 23 23 POINT (440330.7 4638631) ## 2 56 56 POINT (436036.4 4627511) ## 3 70 70 POINT (441795.4 4622026) ## 4 76 76 POINT (430118.3 4647560) ## 5 16 16 POINT (440410.8 4645554) ## 6 19 19 POINT (434989.7 4641362) As we can see, the community area in comm matches the entry in area_num_1. However, there is one more issue to deal with. Upon closer examination, we find that the area_num_1 variable is not numeric using the is.numeric check. is.numeric(comm.pts$area_num_1) ## [1] FALSE So, we proceed to turn this variable into a numeric format using as.integer and then do a quick check by means of is.integer. comm.pts$area_num_1 &lt;- as.integer(comm.pts$area_num_1) is.integer(comm.pts$area_num_1) ## [1] TRUE The same problem occurs in the chicago.comm data set, which can cause trouble later on when we will join it with other data. Therefore, we turn it into an integer as well. chicago.comm$area_num_1 &lt;- as.integer(chicago.comm$area_num_1) Counts by community area We now need to count the number of points in each polygon. We proceed in two steps. First, we illustrate how we can move back from the simple features spatial points object to a simple data frame by stripping the geometry column. This is accomplished by setting st_geometry to NULL. We check the class of the new object to make sure it is no longer a simple feature. st_geometry(comm.pts) &lt;- NULL class(comm.pts) ## [1] &quot;data.frame&quot; We next take advantage of the tidyverse count function to create a new data frame with the identifier of the community area and the number of points contained in each community area. veh.cnts &lt;- comm.pts %&gt;% count(area_num_1) head(veh.cnts) ## # A tibble: 6 x 2 ## area_num_1 n ## &lt;int&gt; &lt;int&gt; ## 1 1 67 ## 2 2 89 ## 3 3 21 ## 4 4 32 ## 5 5 18 ## 6 6 19 The new data frame has two fields: the original identifier area_num_1 and the count as n. We can change the variable names for the count to something more meaningful by means of the tidyverse rename command and turn it from n to AGG.COUNT (to use the same variable as in the GeoDa workbook). Similarly, we also shorten area_num_1 to comm. Again, the new name is on the LHS of the equal sign and the old name on the RHS. veh.cnts &lt;- veh.cnts %&gt;% rename(comm = area_num_1, AGG.COUNT = n) head(veh.cnts) ## # A tibble: 6 x 2 ## comm AGG.COUNT ## &lt;int&gt; &lt;int&gt; ## 1 1 67 ## 2 2 89 ## 3 3 21 ## 4 4 32 ## 5 5 18 ## 6 6 19 Mapping the vehicle counts At this point, we have a polygon layer with the community area boundaries and some identifiers (chicago.comm) and a data frame with the community identifier and the aggregate vehicle count (veh.cnts). In order to map the vehicle counts by community area, we need to join the two tables. We use the left_join command and use area_num_1 as the key for the first table (the community area boundaries), and comm as the key for the second table (the vehicle counts). Since we assured that both variables are now integers, the join will work (if one were a character and the other integer, there would be an error message). Note how in the command below, the two keys can have different variable names (but they must have the same values), which is made explicit in the by statement. chicago.comm &lt;- left_join(chicago.comm,veh.cnts, by = c(&quot;area_num_1&quot; = &quot;comm&quot;)) We can double check that the vehicle counts were added using the head command. head(chicago.comm) ## Simple feature collection with 6 features and 10 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 441440.4 ymin: 4627153 xmax: 451817.1 ymax: 4648971 ## epsg (SRID): 32616 ## proj4string: +proj=utm +zone=16 +datum=WGS84 +units=m +no_defs ## # A tibble: 6 x 11 ## community area shape_area perimeter area_num_1 area_numbe comarea_id comarea ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 DOUGLAS 0 46004621.… 0 35 35 0 0 ## 2 OAKLAND 0 16913961.… 0 36 36 0 0 ## 3 FULLER P… 0 19916704.… 0 37 37 0 0 ## 4 GRAND BO… 0 48492503.… 0 38 38 0 0 ## 5 KENWOOD 0 29071741.… 0 39 39 0 0 ## 6 LINCOLN … 0 71352328.… 0 4 4 0 0 ## # … with 3 more variables: shape_len &lt;chr&gt;, geometry &lt;MULTIPOLYGON [m]&gt;, ## # AGG.COUNT &lt;int&gt; Basic choropleth map As we saw earlier, we can construct rudimentary maps using the plot command in sf, but for further control, we will use the tmap package. This uses a logic similar to Wilkinson's grammar of graphics, which is also the basis for the structure of the plot commands in the ggplot package. We leave a detailed treatment of tmap for a future lab and just use the basic defaults in this example. The commands are layered and always start by specifying a layer using the tm_shape command. In our example, this is chicago.comm. Next (after the plus sign) follow one of more drawing commands that cover a wide range of geographic shapes. Here, we will just use tm_polygons and specify AGG.COUNT as the variable to determine the classification. We leave everything to the default and obtain a map that illustrates the spatial distribution of the abandoned vehicle counts by community area. tm_shape(chicago.comm) + tm_polygons(&quot;AGG.COUNT&quot;) However, this map can be highly misleading since it pertains to a so-called spatially extensive variable, such as a count. Even if every area had the same risk of having abandoned vehicles, larger community areas would have higher counts. In other words, since the count is directly related to the size of the area, it does not provide a proper indication of the risk. Instead, we should map a spatially intensive variable, which is corrected for the size of the unit. For example, this can be achieved by expressing the variable as a density (counts per area), or as some other ratio, such as the counts per capita. In order to calculate this ratio, we first need to obtain the population for each community area. Community Area Population Data The Chicago Community Area 2010 population is contained in a pdf file, available from the City of Chicago web site. This link is to a pdf file that contains a table with the neighborhood ID, the neighborhood name, the populations for 2010 and 2000, the difference between the two years and the percentage difference. The full path to the pdf file is https://www.cityofchicago.org/content/dam/city/depts/zlup/Zoning_Main_Page/Publications/Census_2010_Community_Area_Profiles/Census_2010_and_2000_CA_Populations.pdf Extracting a pdf file A pdf file is difficult to handle as a source of data, since it doesn't contain tags like an html file. We will use the pdftools package that allows us to turn the contents of a pdf file into a list of long character strings. The resulting data structure is somewhat complex and not necessarily easy to parse. However, in our case, the table has such a simple structure that we can extract the population values by doing some sleuthing on which columns contain those values. This will illustrate the power of the various parsing and text extraction functions available in R. We use the pdf_text function from pdftools to turn the pdf file into a list of character strings, one for each page. We specify the URL of the file as the input source. pdf.file &lt;- &quot;https://www.cityofchicago.org/content/dam/city/depts/zlup/Zoning_Main_Page/Publications/Census_2010_Community_Area_Profiles/Census_2010_and_2000_CA_Populations.pdf&quot; pop.dat &lt;- pdf_text(pdf.file) class(pop.dat) ## [1] &quot;character&quot; We check the length of the data object using the length command and find that indeed it has only two elements (one for each page). length(pop.dat) ## [1] 2 Parsing the pdf file The pop.dat object has two entries, one for each page. Each entry is a single string. So, when you check the length of each item, it may be surprising that its length is only 1. That is because the underlying structure is unknown, it is simply a collection of characters contained in the string. For example, the first element, pop.dat[[1]]: length(pop.dat[[1]]) ## [1] 1 We will parse this file by first turning each element into a separate list and then extracting the parts we are interested in. First, to illustrate in detail what is going on, we will go through each step one by one, but then, in order to reach some level of efficiency, we turn it into a loop over the two elements, for (i in 1:2). We start by initializing a vector (nnlist) with an empty character, and confirm that it is indeed initialized. nnlist &lt;- &quot;&quot; nnlist ## [1] &quot;&quot; Next, we create a list of strings, one for each line in the table, by using the strsplit operation. This splits the long string into a list of one string for each line, by using the return character \\n as the separator (the value for the split argument). The resulting list, ppage, contains a list of 44 elements, matching the contents of the first page of the pdf file. ppage &lt;- strsplit(pop.dat[[1]],split=&quot;\\n&quot;) ppage[[1]] ## [1] &quot; CITY OF CHICAGO&quot; ## [2] &quot; CENSUS 2010 AND 2000&quot; ## [3] &quot; Population&quot; ## [4] &quot;Num Community Area 2010 2,000 Difference Percentage&quot; ## [5] &quot; 1 Rogers Park 54,991 63,484 -8,493 -13.4%&quot; ## [6] &quot; 2 West Ridge 71,942 73,199 -1,257 -1.7%&quot; ## [7] &quot; 3 Uptown 56,362 63,551 -7,189 -11.3%&quot; ## [8] &quot; 4 Lincoln Square 39,493 44,574 -5,081 -11.4%&quot; ## [9] &quot; 5 North Center 31,867 31,895 -28 -0.1%&quot; ## [10] &quot; 6 Lake View 94,368 94,817 -449 -0.5%&quot; ## [11] &quot; 7 Lincoln Park 64,116 64,320 -204 -0.3%&quot; ## [12] &quot; 8 Near North Side 80,484 72,811 7,673 10.5%&quot; ## [13] &quot; 9 Edison Park 11,187 11,259 -72 -0.6%&quot; ## [14] &quot; 10 Norwood Park 37,023 37,669 -646 -1.7%&quot; ## [15] &quot; 11 Jefferson Park 25,448 25,859 -411 -1.6%&quot; ## [16] &quot; 12 Forest Glen 18,508 18,165 343 1.9%&quot; ## [17] &quot; 13 North Park 17,931 18,514 -583 -3.1%&quot; ## [18] &quot; 14 Albany Park 51,542 57,655 -6,113 -10.6%&quot; ## [19] &quot; 15 Portage Park 64,124 65,340 -1,216 -1.9%&quot; ## [20] &quot; 16 Irving Park 53,359 58,643 -5,284 -9.0%&quot; ## [21] &quot; 17 Dunning 41,932 42,164 -232 -0.6%&quot; ## [22] &quot; 18 Montclare 13,426 12,646 780 6.2%&quot; ## [23] &quot; 19 Belmont Cragin 78,743 78,144 599 0.8%&quot; ## [24] &quot; 20 Hermosa 25,010 26,908 -1,898 -7.1%&quot; ## [25] &quot; 21 Avondale 39,262 43,083 -3,821 -8.9%&quot; ## [26] &quot; 22 Logan Square 73,595 82,715 -9,120 -11.0%&quot; ## [27] &quot; 23 Humboldt Park 56,323 65,836 -9,513 -14.4%&quot; ## [28] &quot; 24 West Town 81,432 87,435 -6,003 -6.9%&quot; ## [29] &quot; 25 Austin 98,514 117,527 -19,013 -16.2%&quot; ## [30] &quot; 26 West Garfield Park 18,001 23,019 -5,018 -21.8%&quot; ## [31] &quot; 27 East Garfield Park 20,567 20,881 -314 -1.5%&quot; ## [32] &quot; 28 Near West Side 54,881 46,419 8,462 18.2%&quot; ## [33] &quot; 29 North Lawndale 35,912 41,768 -5,856 -14.0%&quot; ## [34] &quot; 30 South Lawndale 79,288 91,071 -11,783 -12.9%&quot; ## [35] &quot; 31 Lower West Side 35,769 44,031 -8,262 -18.8%&quot; ## [36] &quot; 32 Loop 29,283 16,388 12,895 78.7%&quot; ## [37] &quot; 33 Near South Side 21,390 9,509 11,881 124.9%&quot; ## [38] &quot; 34 Armour Square 13,391 12,032 1,359 11.3%&quot; ## [39] &quot; 35 Douglas 18,238 26,470 -8,232 -31.1%&quot; ## [40] &quot; 36 Oakland 5,918 6,110 -192 -3.1%&quot; ## [41] &quot; 37 Fuller Park 2,876 3,420 -544 -15.9%&quot; ## [42] &quot; 38 Grand Boulevard 21,929 28,006 -6,077 -21.7%&quot; ## [43] &quot; 39 Kenwood 17,841 18,363 -522 -2.8%&quot; ## [44] &quot; 40 Washington Park 11,717 14,146 -2,429 -17.2%&quot; Each element is one long string, corresponding to a table row. We remove the first four lines (using the - operation on the list elements 1 through 4). These first rows appear on each page, so we are safe to repeat this procedure for the second page (string) as well. nni &lt;- ppage[[1]] nni &lt;- nni[-(1:4)] nni ## [1] &quot; 1 Rogers Park 54,991 63,484 -8,493 -13.4%&quot; ## [2] &quot; 2 West Ridge 71,942 73,199 -1,257 -1.7%&quot; ## [3] &quot; 3 Uptown 56,362 63,551 -7,189 -11.3%&quot; ## [4] &quot; 4 Lincoln Square 39,493 44,574 -5,081 -11.4%&quot; ## [5] &quot; 5 North Center 31,867 31,895 -28 -0.1%&quot; ## [6] &quot; 6 Lake View 94,368 94,817 -449 -0.5%&quot; ## [7] &quot; 7 Lincoln Park 64,116 64,320 -204 -0.3%&quot; ## [8] &quot; 8 Near North Side 80,484 72,811 7,673 10.5%&quot; ## [9] &quot; 9 Edison Park 11,187 11,259 -72 -0.6%&quot; ## [10] &quot; 10 Norwood Park 37,023 37,669 -646 -1.7%&quot; ## [11] &quot; 11 Jefferson Park 25,448 25,859 -411 -1.6%&quot; ## [12] &quot; 12 Forest Glen 18,508 18,165 343 1.9%&quot; ## [13] &quot; 13 North Park 17,931 18,514 -583 -3.1%&quot; ## [14] &quot; 14 Albany Park 51,542 57,655 -6,113 -10.6%&quot; ## [15] &quot; 15 Portage Park 64,124 65,340 -1,216 -1.9%&quot; ## [16] &quot; 16 Irving Park 53,359 58,643 -5,284 -9.0%&quot; ## [17] &quot; 17 Dunning 41,932 42,164 -232 -0.6%&quot; ## [18] &quot; 18 Montclare 13,426 12,646 780 6.2%&quot; ## [19] &quot; 19 Belmont Cragin 78,743 78,144 599 0.8%&quot; ## [20] &quot; 20 Hermosa 25,010 26,908 -1,898 -7.1%&quot; ## [21] &quot; 21 Avondale 39,262 43,083 -3,821 -8.9%&quot; ## [22] &quot; 22 Logan Square 73,595 82,715 -9,120 -11.0%&quot; ## [23] &quot; 23 Humboldt Park 56,323 65,836 -9,513 -14.4%&quot; ## [24] &quot; 24 West Town 81,432 87,435 -6,003 -6.9%&quot; ## [25] &quot; 25 Austin 98,514 117,527 -19,013 -16.2%&quot; ## [26] &quot; 26 West Garfield Park 18,001 23,019 -5,018 -21.8%&quot; ## [27] &quot; 27 East Garfield Park 20,567 20,881 -314 -1.5%&quot; ## [28] &quot; 28 Near West Side 54,881 46,419 8,462 18.2%&quot; ## [29] &quot; 29 North Lawndale 35,912 41,768 -5,856 -14.0%&quot; ## [30] &quot; 30 South Lawndale 79,288 91,071 -11,783 -12.9%&quot; ## [31] &quot; 31 Lower West Side 35,769 44,031 -8,262 -18.8%&quot; ## [32] &quot; 32 Loop 29,283 16,388 12,895 78.7%&quot; ## [33] &quot; 33 Near South Side 21,390 9,509 11,881 124.9%&quot; ## [34] &quot; 34 Armour Square 13,391 12,032 1,359 11.3%&quot; ## [35] &quot; 35 Douglas 18,238 26,470 -8,232 -31.1%&quot; ## [36] &quot; 36 Oakland 5,918 6,110 -192 -3.1%&quot; ## [37] &quot; 37 Fuller Park 2,876 3,420 -544 -15.9%&quot; ## [38] &quot; 38 Grand Boulevard 21,929 28,006 -6,077 -21.7%&quot; ## [39] &quot; 39 Kenwood 17,841 18,363 -522 -2.8%&quot; ## [40] &quot; 40 Washington Park 11,717 14,146 -2,429 -17.2%&quot; To streamline the resulting data structure for further operations, we turn it into a simple vector by means of unlist. This then allows us to concatenate the result to the current nnlist vector (initially, this contains just a single element with an empty character, after the first step it contains the empty character and the first page). nnu &lt;- unlist(nni) nnlist &lt;- c(nnlist,nnu) nnlist ## [1] &quot;&quot; ## [2] &quot; 1 Rogers Park 54,991 63,484 -8,493 -13.4%&quot; ## [3] &quot; 2 West Ridge 71,942 73,199 -1,257 -1.7%&quot; ## [4] &quot; 3 Uptown 56,362 63,551 -7,189 -11.3%&quot; ## [5] &quot; 4 Lincoln Square 39,493 44,574 -5,081 -11.4%&quot; ## [6] &quot; 5 North Center 31,867 31,895 -28 -0.1%&quot; ## [7] &quot; 6 Lake View 94,368 94,817 -449 -0.5%&quot; ## [8] &quot; 7 Lincoln Park 64,116 64,320 -204 -0.3%&quot; ## [9] &quot; 8 Near North Side 80,484 72,811 7,673 10.5%&quot; ## [10] &quot; 9 Edison Park 11,187 11,259 -72 -0.6%&quot; ## [11] &quot; 10 Norwood Park 37,023 37,669 -646 -1.7%&quot; ## [12] &quot; 11 Jefferson Park 25,448 25,859 -411 -1.6%&quot; ## [13] &quot; 12 Forest Glen 18,508 18,165 343 1.9%&quot; ## [14] &quot; 13 North Park 17,931 18,514 -583 -3.1%&quot; ## [15] &quot; 14 Albany Park 51,542 57,655 -6,113 -10.6%&quot; ## [16] &quot; 15 Portage Park 64,124 65,340 -1,216 -1.9%&quot; ## [17] &quot; 16 Irving Park 53,359 58,643 -5,284 -9.0%&quot; ## [18] &quot; 17 Dunning 41,932 42,164 -232 -0.6%&quot; ## [19] &quot; 18 Montclare 13,426 12,646 780 6.2%&quot; ## [20] &quot; 19 Belmont Cragin 78,743 78,144 599 0.8%&quot; ## [21] &quot; 20 Hermosa 25,010 26,908 -1,898 -7.1%&quot; ## [22] &quot; 21 Avondale 39,262 43,083 -3,821 -8.9%&quot; ## [23] &quot; 22 Logan Square 73,595 82,715 -9,120 -11.0%&quot; ## [24] &quot; 23 Humboldt Park 56,323 65,836 -9,513 -14.4%&quot; ## [25] &quot; 24 West Town 81,432 87,435 -6,003 -6.9%&quot; ## [26] &quot; 25 Austin 98,514 117,527 -19,013 -16.2%&quot; ## [27] &quot; 26 West Garfield Park 18,001 23,019 -5,018 -21.8%&quot; ## [28] &quot; 27 East Garfield Park 20,567 20,881 -314 -1.5%&quot; ## [29] &quot; 28 Near West Side 54,881 46,419 8,462 18.2%&quot; ## [30] &quot; 29 North Lawndale 35,912 41,768 -5,856 -14.0%&quot; ## [31] &quot; 30 South Lawndale 79,288 91,071 -11,783 -12.9%&quot; ## [32] &quot; 31 Lower West Side 35,769 44,031 -8,262 -18.8%&quot; ## [33] &quot; 32 Loop 29,283 16,388 12,895 78.7%&quot; ## [34] &quot; 33 Near South Side 21,390 9,509 11,881 124.9%&quot; ## [35] &quot; 34 Armour Square 13,391 12,032 1,359 11.3%&quot; ## [36] &quot; 35 Douglas 18,238 26,470 -8,232 -31.1%&quot; ## [37] &quot; 36 Oakland 5,918 6,110 -192 -3.1%&quot; ## [38] &quot; 37 Fuller Park 2,876 3,420 -544 -15.9%&quot; ## [39] &quot; 38 Grand Boulevard 21,929 28,006 -6,077 -21.7%&quot; ## [40] &quot; 39 Kenwood 17,841 18,363 -522 -2.8%&quot; ## [41] &quot; 40 Washington Park 11,717 14,146 -2,429 -17.2%&quot; We now repeat this operation for pop.dat[[2]]. More efficiently, we implement it as a loop, replacing i in turn by 1 and 2. This yields: nnlist &lt;- &quot;&quot; for (i in 1:2) { ppage &lt;- strsplit(pop.dat[[i]],split=&quot;\\n&quot;) nni &lt;- ppage[[1]] nni &lt;- nni[-(1:4)] nnu &lt;- unlist(nni) nnlist &lt;- c(nnlist,nnu) } At the end of the loop, we check the contents of the vector nnlist. nnlist ## [1] &quot;&quot; ## [2] &quot; 1 Rogers Park 54,991 63,484 -8,493 -13.4%&quot; ## [3] &quot; 2 West Ridge 71,942 73,199 -1,257 -1.7%&quot; ## [4] &quot; 3 Uptown 56,362 63,551 -7,189 -11.3%&quot; ## [5] &quot; 4 Lincoln Square 39,493 44,574 -5,081 -11.4%&quot; ## [6] &quot; 5 North Center 31,867 31,895 -28 -0.1%&quot; ## [7] &quot; 6 Lake View 94,368 94,817 -449 -0.5%&quot; ## [8] &quot; 7 Lincoln Park 64,116 64,320 -204 -0.3%&quot; ## [9] &quot; 8 Near North Side 80,484 72,811 7,673 10.5%&quot; ## [10] &quot; 9 Edison Park 11,187 11,259 -72 -0.6%&quot; ## [11] &quot; 10 Norwood Park 37,023 37,669 -646 -1.7%&quot; ## [12] &quot; 11 Jefferson Park 25,448 25,859 -411 -1.6%&quot; ## [13] &quot; 12 Forest Glen 18,508 18,165 343 1.9%&quot; ## [14] &quot; 13 North Park 17,931 18,514 -583 -3.1%&quot; ## [15] &quot; 14 Albany Park 51,542 57,655 -6,113 -10.6%&quot; ## [16] &quot; 15 Portage Park 64,124 65,340 -1,216 -1.9%&quot; ## [17] &quot; 16 Irving Park 53,359 58,643 -5,284 -9.0%&quot; ## [18] &quot; 17 Dunning 41,932 42,164 -232 -0.6%&quot; ## [19] &quot; 18 Montclare 13,426 12,646 780 6.2%&quot; ## [20] &quot; 19 Belmont Cragin 78,743 78,144 599 0.8%&quot; ## [21] &quot; 20 Hermosa 25,010 26,908 -1,898 -7.1%&quot; ## [22] &quot; 21 Avondale 39,262 43,083 -3,821 -8.9%&quot; ## [23] &quot; 22 Logan Square 73,595 82,715 -9,120 -11.0%&quot; ## [24] &quot; 23 Humboldt Park 56,323 65,836 -9,513 -14.4%&quot; ## [25] &quot; 24 West Town 81,432 87,435 -6,003 -6.9%&quot; ## [26] &quot; 25 Austin 98,514 117,527 -19,013 -16.2%&quot; ## [27] &quot; 26 West Garfield Park 18,001 23,019 -5,018 -21.8%&quot; ## [28] &quot; 27 East Garfield Park 20,567 20,881 -314 -1.5%&quot; ## [29] &quot; 28 Near West Side 54,881 46,419 8,462 18.2%&quot; ## [30] &quot; 29 North Lawndale 35,912 41,768 -5,856 -14.0%&quot; ## [31] &quot; 30 South Lawndale 79,288 91,071 -11,783 -12.9%&quot; ## [32] &quot; 31 Lower West Side 35,769 44,031 -8,262 -18.8%&quot; ## [33] &quot; 32 Loop 29,283 16,388 12,895 78.7%&quot; ## [34] &quot; 33 Near South Side 21,390 9,509 11,881 124.9%&quot; ## [35] &quot; 34 Armour Square 13,391 12,032 1,359 11.3%&quot; ## [36] &quot; 35 Douglas 18,238 26,470 -8,232 -31.1%&quot; ## [37] &quot; 36 Oakland 5,918 6,110 -192 -3.1%&quot; ## [38] &quot; 37 Fuller Park 2,876 3,420 -544 -15.9%&quot; ## [39] &quot; 38 Grand Boulevard 21,929 28,006 -6,077 -21.7%&quot; ## [40] &quot; 39 Kenwood 17,841 18,363 -522 -2.8%&quot; ## [41] &quot; 40 Washington Park 11,717 14,146 -2,429 -17.2%&quot; ## [42] &quot; 41 Hyde Park 25,681 29,920 -4,239 -14.2%&quot; ## [43] &quot; 42 Woodlawn 25,983 27,086 -1,103 -4.1%&quot; ## [44] &quot; 43 South Shore 49,767 61,556 -11,789 -19.2%&quot; ## [45] &quot; 44 Chatham 31,028 37,275 -6,247 -16.8%&quot; ## [46] &quot; 45 Avalon Park 10,185 11,147 -962 -8.6%&quot; ## [47] &quot; 46 South Chicago 31,198 38,596 -7,398 -19.2%&quot; ## [48] &quot; 47 Burnside 2,916 3,294 -378 -11.5%&quot; ## [49] &quot; 48 Calumet Heights 13,812 15,974 -2,162 -13.5%&quot; ## [50] &quot; 49 Roseland 44,619 52,723 -8,104 -15.4%&quot; ## [51] &quot; 50 Pullman 7,325 8,921 -1,596 -17.9%&quot; ## [52] &quot; 51 South Deering 15,109 16,990 -1,881 -11.1%&quot; ## [53] &quot; 52 East Side 23,042 23,653 -611 -2.6%&quot; ## [54] &quot; 53 West Pullman 29,651 36,649 -6,998 -19.1%&quot; ## [55] &quot; 54 Riverdale 6,482 9,809 -3,327 -33.9%&quot; ## [56] &quot; 55 Hegewisch 9,426 9,781 -355 -3.6%&quot; ## [57] &quot; 56 Garfield Ridge 34,513 36,101 -1,588 -4.4%&quot; ## [58] &quot; 57 Archer Heights 13,393 12,644 749 5.9%&quot; ## [59] &quot; 58 Brighton Park 45,368 44,912 456 1.0%&quot; ## [60] &quot; 59 McKinley Park 15,612 15,962 -350 -2.2%&quot; ## [61] &quot; 60 Bridgeport 31,977 33,694 -1,717 -5.1%&quot; ## [62] &quot; 61 New City 44,377 51,721 -7,344 -14.2%&quot; ## [63] &quot; 62 West Elsdon 18,109 15,921 2,188 13.7%&quot; ## [64] &quot; 63 Gage Park 39,894 39,193 701 1.8%&quot; ## [65] &quot; 64 Clearing 23,139 22,331 808 3.6%&quot; ## [66] &quot; 65 West Lawn 33,355 29,235 4,120 14.1%&quot; ## [67] &quot; 66 Chicago Lawn 55,628 61,412 -5,784 -9.4%&quot; ## [68] &quot; 67 West Englewood 35,505 45,282 -9,777 -21.6%&quot; ## [69] &quot; 68 Englewood 30,654 40,222 -9,568 -23.8%&quot; ## [70] &quot; 69 Greater Grand Crossing 32,602 38,619 -6,017 -15.6%&quot; ## [71] &quot; 70 Ashburn 41,081 39,584 1,497 3.8%&quot; ## [72] &quot; 71 Auburn Gresham 48,743 55,928 -7,185 -12.8%&quot; ## [73] &quot; 72 Beverly 20,034 21,992 -1,958 -8.9%&quot; ## [74] &quot; 73 Washington Heights 26,493 29,843 -3,350 -11.2%&quot; ## [75] &quot; 74 Mount Greenwood 19,093 18,820 273 1.5%&quot; ## [76] &quot; 75 Morgan Park 22,544 25,226 -2,682 -10.6%&quot; ## [77] &quot; 76 O&#39;Hare 12,756 11,956 800 6.7%&quot; ## [78] &quot; 77 Edgewater 56,521 62,198 -5,677 -9.1%&quot; ## [79] &quot; Total 2,695,598 2,896,016 -200,418 -6.9%&quot; This is now a vector of 79 elements, each of which is a string. To clean things up, strip the first (empty) element, and the last element, which is nothing but the totals. We thus extract the elements from 2 to length - 1. nnlist &lt;- nnlist[2:(length(nnlist)-1)] 1.0.1 Extracting the population values We first initialize a vector of zeros to hold the population values. It is the preferred approach to initialize a vector first if one knows its size, rather than having it grow by appending rows or columns. We use the vector command and specify the mode=&quot;numeric&quot; and give the length as the length of the list. nnpop &lt;- vector(mode=&quot;numeric&quot;,length=length(nnlist)) We again will use a loop to process each element of the list (each line of the table) one by one. We use the substr command to extract the characters between position 27 and 39 (these values were determined after taking a careful look at the structure of the table). However, there is still a problem, since the population values contain commas. We now do two things in one line of code. First, we use gsub to substitute the comma character by an empty &quot;&quot;. We turn the result into a numeric value by means of as.numeric. We then assign this number to position i of the vector. The resulting vector nnpop contains the population for each of the community areas. for (i in (1:length(nnlist))) { popchar &lt;- substr(nnlist[i],start=27,stop=39) popval &lt;- as.numeric(gsub(&quot;,&quot;,&quot;&quot;,popchar)) nnpop[i] &lt;- popval } nnpop ## [1] 54991 71942 56362 39493 31867 94368 64116 80484 11187 37023 25448 18508 ## [13] 17931 51542 64124 53359 41932 13426 78743 25010 39262 73595 56323 81432 ## [25] 98514 18001 20567 54881 35912 79288 35769 29283 21390 13391 18238 5918 ## [37] 2876 21929 17841 11717 25681 25983 49767 31028 10185 31198 2916 13812 ## [49] 44619 7325 15109 23042 29651 6482 9426 34513 13393 45368 15612 31977 ## [61] 44377 18109 39894 23139 33355 55628 35505 30654 32602 41081 48743 20034 ## [73] 26493 19093 22544 12756 56521 Creating a data frame with population values As a final step in the process of collecting the community area population information, we combine the vector with the population counts and a vector with community ID information into a data frame. Since the community area indicators are simple sequence numbers, we create such a vector to serve as the ID, again using the length of the vector to determine the extent. nnid &lt;- (1:length(nnlist)) nnid ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ## [51] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 ## [76] 76 77 We turn the vectors nnid and nnpop into a data frame using the data.frame command. Since the variable names assigned automatically are not that informative, we next force them to NID and POP2010 using the names command. Also, as we did before, we make sure the ID variable is an integer (for merging in GeoDa) by means of as.integer. neighpop &lt;- data.frame(as.integer(nnid),nnpop) names(neighpop) &lt;- c(&quot;NID&quot;,&quot;POP2010&quot;) head(neighpop) ## NID POP2010 ## 1 1 54991 ## 2 2 71942 ## 3 3 56362 ## 4 4 39493 ## 5 5 31867 ## 6 6 94368 Mapping Community Area Abandoned Vehicles Per Capita Computing abandoned vehicles per capita Before proceeding further, we left_join the community population data to the community area layer, in the same way as we did for the vehicle counts. chicago.comm &lt;- left_join(chicago.comm,neighpop, by = c(&quot;area_num_1&quot; = &quot;NID&quot;)) head(chicago.comm) ## Simple feature collection with 6 features and 11 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 441440.4 ymin: 4627153 xmax: 451817.1 ymax: 4648971 ## epsg (SRID): 32616 ## proj4string: +proj=utm +zone=16 +datum=WGS84 +units=m +no_defs ## # A tibble: 6 x 12 ## community area shape_area perimeter area_num_1 area_numbe comarea_id comarea ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 DOUGLAS 0 46004621.… 0 35 35 0 0 ## 2 OAKLAND 0 16913961.… 0 36 36 0 0 ## 3 FULLER P… 0 19916704.… 0 37 37 0 0 ## 4 GRAND BO… 0 48492503.… 0 38 38 0 0 ## 5 KENWOOD 0 29071741.… 0 39 39 0 0 ## 6 LINCOLN … 0 71352328.… 0 4 4 0 0 ## # … with 4 more variables: shape_len &lt;chr&gt;, geometry &lt;MULTIPOLYGON [m]&gt;, ## # AGG.COUNT &lt;int&gt;, POP2010 &lt;dbl&gt; We will now create a new variable using the tidyverse mutate command as the ratio of vehicle counts per 1000 population. chicago.comm &lt;- chicago.comm %&gt;% mutate(vehpcap = (AGG.COUNT / POP2010) * 1000) head(chicago.comm) ## Simple feature collection with 6 features and 12 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 441440.4 ymin: 4627153 xmax: 451817.1 ymax: 4648971 ## epsg (SRID): 32616 ## proj4string: +proj=utm +zone=16 +datum=WGS84 +units=m +no_defs ## # A tibble: 6 x 13 ## community area shape_area perimeter area_num_1 area_numbe comarea_id comarea ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 DOUGLAS 0 46004621.… 0 35 35 0 0 ## 2 OAKLAND 0 16913961.… 0 36 36 0 0 ## 3 FULLER P… 0 19916704.… 0 37 37 0 0 ## 4 GRAND BO… 0 48492503.… 0 38 38 0 0 ## 5 KENWOOD 0 29071741.… 0 39 39 0 0 ## 6 LINCOLN … 0 71352328.… 0 4 4 0 0 ## # … with 5 more variables: shape_len &lt;chr&gt;, geometry &lt;MULTIPOLYGON [m]&gt;, ## # AGG.COUNT &lt;int&gt;, POP2010 &lt;dbl&gt;, vehpcap &lt;dbl&gt; Final choropleth map For our final choropleth, we use the same procedure as for the vehicle counts, but take vehpcap as the variable instead. tm_shape(chicago.comm) + tm_polygons(&quot;vehpcap&quot;) When compared to the total counts, we see quite a different spatial distribution. In particular, the locations of the highest ratios are quite different from those of the highest counts. As a rule, one should never create a choropleth map of a spatially extensive variable, unless the size of the areal units is somehow controlled for (e.g., equal area grid cells, or equal population zones). 1.0.1.1 Optional - save the community area file as a shape file Finally, we can write the community area layer to the working directory. Note that, so far, all operations have been carried out in memory, and when you close the program, everything will be lost (unless you save your workspace). We can write the community area to a shape file (actually, four files contained in a directory) by means of the sf command st_write. This command has many options, but we just use the minimal ones. The chicago.comm object will be written to a set of files in the directory chicago_vehicles using the ESRI Shapefile format. Note that if the directory already exists, it should be deleted or renamed first, since st_write only creates a new directory. Otherwise, there will be an error message. st_write(chicago.comm,&quot;chicago_vehicles&quot;,driver=&quot;ESRI Shapefile&quot;) ## Writing layer `chicago_vehicles&#39; to data source `chicago_vehicles&#39; using driver `ESRI Shapefile&#39; ## Writing 77 features with 12 fields and geometry type Multi Polygon. Use setwd(directorypath) to specify the working directory.↩ Use install.packages(packagename).↩ A good resource on coordinate reference systems is the spatialreference.org site, which contains thousands of references in a variety of commonly used formats.↩ "],
["exploratory-data-analysis-1.html", "Chapter 2 Exploratory Data Analysis 1 Introduction Preliminaries Analyzing the Distribution of a Single Variable Bivariate Analysis: The Scatter Plot Spatial heterogeneity", " Chapter 2 Exploratory Data Analysis 1 Introduction This notebook covers the functionality of the Exploratory Data Analysis 1 section of the GeoDa workbook. We refer to that document for details on the methodology, references, etc. The goal of these notes is to approximate as closely as possible the operations carried out using GeoDa by means of a range of R packages. The notes are written with R beginners in mind, more seasoned R users can probably skip most of the comments on data structures and other R particulars. Also, as always in R, there are typically several ways to achieve a specific objective, so what is shown here is just one way that works, but there often are others (that may even be more elegant, work faster, or scale better). For this notebook, we will use socioeconomic data for 55 New York City sub-boroughs from the GeoDa website. Our goal in this lab is show how to implement exploratory data analysis methods that deal with one (univariate) and two (bivariate) variables. Objectives After completing the notebook, you should know how to carry out the following tasks: Creating basic univariate plots, i.e., histogram and box plot Creating a scatter plot Implementing different smoothing methods in a scatter plot (linear, loess, and lowess) Showing linear fits for different subsets of the data (spatial heterogeneity) Testing the constancy of a regression slope (Chow test) R Packages used tidyverse: for general data wrangling (includes readr and dplyr) ggplot2: to make statistical plots; we use this rather than base R for increased functionality and more aesthetically pleasing plots (also part of tidyverse) ggthemes: additional themes for use with ggplot Hmisc: contains a LOWESS smoother for ggplot gap: to run the chow test R Commands used Below follows a list of the commands used in this notebook. For further details and a comprehensive list of options, please consult the R documentation. Base R: setwd, install.packages, library, head, names, summary, range, var, sd,pdf,dev.off,saveRDS,readRDS, function, lm, str, dim tidyverse: read_csv, rename, mutate, if_else, filter ggplot2: ggplot, geom_histogram, bins, theme_classic, theme_minimal, xlab, ylab, ggtitle, theme, layer_data, ggsave, geom_boxplot, stat_boxplot, geom_point, coord_fixed, geom_smooth, stat_smooth, labs, scale_color_manual ggthemes: theme_tufte Hmisc: stat_plsmo gap: chow.test Preliminaries Before starting, make sure to have the latest version of R and of packages that are compiled for the matching version of R (this document was created using R 3.5.1 of 2018-07-02). Also, make sure to set a working directory.4 We will use a relative path to the working directory to read the data set. Load packages First, we load all the required packages using the library command. If you don't have some of these in your system, make sure to install them first as well as their dependencies.5 You will get an error message if something is missing. If needed, just install the missing piece and everything will work after that. Note that ggplot2 does not need to be loaded separately since it is included in the tidyverse package collection. library(tidyverse) library(ggthemes) library(Hmisc) ## Loading required package: lattice ## Loading required package: survival ## Loading required package: Formula ## ## Attaching package: &#39;Hmisc&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## src, summarize ## The following objects are masked from &#39;package:base&#39;: ## ## format.pval, units library(gap) ## gap version 1.2.2 library(geodaData) Obtaining the data The data to implement the operations in this workbook are contained in NYC Data on the GeoDa support web site. After the file is downloaded, it must be unzipped (e.g., double click on the file). The nyc folder should be moved to the current working directory for the path names we use below to work correctly. Creating an initial data frame We use the tidyverse function read_csv to read the data into a data frame nyc.data. We could also have used the base R read.csv, but read_csv is a bit more robust and creates a tibble, a data frame with some additional information. As usual, we check the contents of the data frame with a head command. nyc.data &lt;- nyc head(nyc.data) ## # A tibble: 6 x 34 ## bor_subb NAME CODE SUBBOROUGH FORHIS06 FORHIS07 FORHIS08 FORHIS09 FORWH06 ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 501 Nort… 501 North Sho… 37.1 34.0 27.4 29.3 13.3 ## 2 502 Mid-… 502 Mid-Island 28.0 18.1 24.0 31.2 20.1 ## 3 503 Sout… 503 South Sho… 10.7 12.1 9.69 14.7 10.3 ## 4 401 Asto… 401 Astoria 52.1 54.0 54.7 47.8 38.4 ## 5 402 Sunn… 402 Sunnyside… 62.7 69.4 67.1 58.3 37.1 ## 6 403 Jack… 403 Jackson H… 68.5 68.5 66.5 69.2 34.4 ## # … with 25 more variables: FORWH07 &lt;dbl&gt;, FORWH08 &lt;dbl&gt;, FORWH09 &lt;dbl&gt;, ## # HHSIZ1990 &lt;dbl&gt;, HHSIZ00 &lt;dbl&gt;, HHSIZ02 &lt;dbl&gt;, HHSIZ05 &lt;dbl&gt;, ## # HHSIZ08 &lt;dbl&gt;, KIDS2000 &lt;dbl&gt;, KIDS2005 &lt;dbl&gt;, KIDS2006 &lt;dbl&gt;, ## # KIDS2007 &lt;dbl&gt;, KIDS2008 &lt;dbl&gt;, KIDS2009 &lt;dbl&gt;, RENT2002 &lt;dbl&gt;, ## # RENT2005 &lt;dbl&gt;, RENT2008 &lt;dbl&gt;, RENTPCT02 &lt;dbl&gt;, RENTPCT05 &lt;dbl&gt;, ## # RENTPCT08 &lt;dbl&gt;, PUBAST90 &lt;dbl&gt;, PUBAST00 &lt;dbl&gt;, YRHOM02 &lt;dbl&gt;, ## # YRHOM05 &lt;dbl&gt;, YRHOM08 &lt;dbl&gt; Making the variable names compatible Note, that in contrast to GeoDa (where the dbf file is read), reading the csv file into a data frame results in almost all the variable names being in caps. We confirm this with a names command: names(nyc.data) ## [1] &quot;bor_subb&quot; &quot;NAME&quot; &quot;CODE&quot; &quot;SUBBOROUGH&quot; &quot;FORHIS06&quot; ## [6] &quot;FORHIS07&quot; &quot;FORHIS08&quot; &quot;FORHIS09&quot; &quot;FORWH06&quot; &quot;FORWH07&quot; ## [11] &quot;FORWH08&quot; &quot;FORWH09&quot; &quot;HHSIZ1990&quot; &quot;HHSIZ00&quot; &quot;HHSIZ02&quot; ## [16] &quot;HHSIZ05&quot; &quot;HHSIZ08&quot; &quot;KIDS2000&quot; &quot;KIDS2005&quot; &quot;KIDS2006&quot; ## [21] &quot;KIDS2007&quot; &quot;KIDS2008&quot; &quot;KIDS2009&quot; &quot;RENT2002&quot; &quot;RENT2005&quot; ## [26] &quot;RENT2008&quot; &quot;RENTPCT02&quot; &quot;RENTPCT05&quot; &quot;RENTPCT08&quot; &quot;PUBAST90&quot; ## [31] &quot;PUBAST00&quot; &quot;YRHOM02&quot; &quot;YRHOM05&quot; &quot;YRHOM08&quot; We now use the tidyverse rename function to turn the all-caps variables into lower case for the examples we will use. As in the GeoDa workbook, we only use three variables, kids2009, kids2000, and pubast00. nyc.data &lt;- nyc.data %&gt;% rename(&quot;kids2009&quot; = &quot;KIDS2009&quot;, &quot;kids2000&quot; = &quot;KIDS2000&quot;, &quot;pubast00&quot; = &quot;PUBAST00&quot;) names(nyc.data) ## [1] &quot;bor_subb&quot; &quot;NAME&quot; &quot;CODE&quot; &quot;SUBBOROUGH&quot; &quot;FORHIS06&quot; ## [6] &quot;FORHIS07&quot; &quot;FORHIS08&quot; &quot;FORHIS09&quot; &quot;FORWH06&quot; &quot;FORWH07&quot; ## [11] &quot;FORWH08&quot; &quot;FORWH09&quot; &quot;HHSIZ1990&quot; &quot;HHSIZ00&quot; &quot;HHSIZ02&quot; ## [16] &quot;HHSIZ05&quot; &quot;HHSIZ08&quot; &quot;kids2000&quot; &quot;KIDS2005&quot; &quot;KIDS2006&quot; ## [21] &quot;KIDS2007&quot; &quot;KIDS2008&quot; &quot;kids2009&quot; &quot;RENT2002&quot; &quot;RENT2005&quot; ## [26] &quot;RENT2008&quot; &quot;RENTPCT02&quot; &quot;RENTPCT05&quot; &quot;RENTPCT08&quot; &quot;PUBAST90&quot; ## [31] &quot;pubast00&quot; &quot;YRHOM02&quot; &quot;YRHOM05&quot; &quot;YRHOM08&quot; Analyzing the Distribution of a Single Variable We follow the discussion in the GeoDa workbook and start with the common univariate descriptive graphs, the histogram and box plot. Before covering the specifics, we provide a brief overview of the principles behind the ggplot operations. Note that linking and brushing between a plot and a map is not (yet) readily implemented in R, so that our discussion will focus primarily on static graphs. A quick introduction to ggplot We will be using the commands in the ggplot2 package for the descriptive statistics plots. There are many options to create nice looking graphs in R, including the functionality in base R, but we chose ggplot2 for its clean logic and its similarity to the tmap package that we already encountered (in fact, tmap uses the same layered logic as ggplot).6 An in-depth introduction to ggplot is beyond our scope, but a quick overview can be found in the Data Visualization chapter of Wickham and Grolemund's R for Data Science book, and full details are covered in Wickham's ggplot2: elegant graphics for data analysis (2nd Edition) (Springer Verlag, 2016). The logic behind ggplot is an implementation of Wilkinson's grammar for graphics, using the concept of layers. These are the components that make up a plot, such as a data set, aesthetic mappings (variables for different aspects of the graph, such as the x and y-axes, colors, shapes, etc.), statistical transformations, a geometric object and position adjustments. Several layers can be drawn on top of each other, providing the ability to create incredibly complex graphs. For now, the main parts to concentrate on are the data set and the aesthetics, or aes. The latter are typically (at least) the variables to be plotted. These are usually declared in the main ggplot command, e.g., ggplot(dataset,aes(x=var1,y=var2)) and apply to all the following layers. However, they can also be specified for each layer individually. Next follow one or more geometric objects, geom_* and various adjustments, added to the first command by means of a plus sign, just as we saw how a tmap choropleth map was constructed. The terminology may seem a little unfamiliar at first, but as long as you remember that aes are the variables and the geom_* are the plot types, you will be on your way. Histogram We start with the simple histogram command. As in the GeoDa workbook, we will use the kids2009 variable. The geom for a histogram is geom_histogram. In contrast to most plots in ggplot, only one variable needs to be passed. The general setup for ggplot is to think of the graph as a two-dimensional representation, with the x variable for the x axis and the y variable for the y-axis. In a histogram, the vertical axis is by default taken to be the count of the observations in each bin.7 The three pieces we need to create the plot are the data set (data), nyc.data, the aesthetic (aes), kids2009, and the geom, geom_histogram. The command is as follows, with all the other settings left to their default: ggplot(data=nyc.data,aes(kids2009)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. The resulting histogram is not very informative, and the first thing we will do is heed the warning to pick a better bin width. Selecting the number of histogram bins The standard way in ggplot is to adjust the number of bins indirectly, by means of the binwidth option, i.e., the range of values that make up a bin, in the units of the variable under consideration. To keep the parallel with the GeoDa workbook, we instead use the option bins, which sets the number of bins directly. The resulting histogram now matches the one in GeoDa (except for the lack of color, which is immaterial). ggplot(data=nyc.data,aes(kids2009)) + geom_histogram(bins=7) As in the GeoDa workbook, we can now change the number of bins to 5, which yields the following histogram. ggplot(data=nyc.data,aes(kids2009)) + geom_histogram(bins=5) Spiffing up the graph The graph as shown is just rudimentary. There are many options in ggplot to change the appearance of the graph, too many to cover here. But to illustrate some basic features, below, we add a label for the x and y axes using xlab and ylab, and a title for the graph with ggtitle. An unfortunate aspect of the latter is that it left aligns the text, whereas we would typically want it to be centered over the graph. We can adjust this using the very powerful theme option. But first the basics. Every graph has a theme, which sets the main parameters for its appearance. The default theme with the grey grids, separated by white lines is theme_grey( ). If we want to change this, we can specify one of the other themes. For example, a classic graph a la base R plot, without background shading or grid lines is theme_classic( ). In order to obtain this specialized look, we set the associated theme command. Our histogram in this theme looks as follows, with a label on the x and y axis, and a title (and back to 7 bins). ggplot(data=nyc.data,aes(kids2009)) + geom_histogram(bins=7) + xlab(&quot;Percent kids in 2009&quot;) + ylab(&quot;Frequency&quot;) + ggtitle(&quot;Example Histogram&quot;) + theme_classic() There are seven built-in themes as well as several contributed ones. Another built-in example is theme_minimal( ), shown next. ggplot(data=nyc.data,aes(kids2009)) + geom_histogram(bins=7) + xlab(&quot;Percent kids in 2009&quot;) + ylab(&quot;Frequency&quot;) + ggtitle(&quot;Example Histogram&quot;) + theme_minimal() In addition, the package ggthemes contains several additional themes that look extremely professional. For example, theme_tufte( ). ggplot(data=nyc.data,aes(kids2009)) + geom_histogram(bins=7) + xlab(&quot;Percent kids in 2009&quot;) + ylab(&quot;Frequency&quot;) + ggtitle(&quot;Example Histogram&quot;) + theme_tufte() Besides selecting a different default theme, we can also override the basic settings associated with the current theme. For example, we adjust the plot.title (of course, you need to know what everything is called). Specifically, we set the element_text property's horizontal justification (hjust) to 0.5. This centers the title. The number of other refinements is near infinite. Again, using the default theme_grey( ): ggplot(data=nyc.data,aes(kids2009)) + geom_histogram(bins=7) + xlab(&quot;Percent kids in 2009&quot;) + ylab(&quot;Frequency&quot;) + ggtitle(&quot;Example Histogram&quot;) + theme(plot.title = element_text(hjust = 0.5)) Histogram summary statistics The histogram in GeoDa has an option to display the contents of each bin as well as some descriptive statistics. As anything in R, the plot created by ggplot is nothing but an object. When we enter the commands as above, starting with ggplot, the result is drawn directly to the screen. But we can also assign the plot object to a variable. This variable will then contain all the information needed to draw the graph, which includes the count of observations in each bin, the min and max values for each bin, etc. For example, we can assign our histogram plot to the plot.data object, and then extract the information using the layer_data function. The result is a data frame. plot.data &lt;- ggplot(data=nyc.data,aes(kids2009)) + geom_histogram(bins=7) + xlab(&quot;Percent kids in 2009&quot;) + ylab(&quot;Frequency&quot;) + ggtitle(&quot;Example Histogram&quot;) + theme(plot.title = element_text(hjust = 0.5)) layer_data(plot.data) ## y count x xmin xmax density ncount ndensity ## 1 1 1 0.0000 -4.0109 4.0109 0.002266551 0.05555556 0.05555556 ## 2 2 2 8.0218 4.0109 12.0327 0.004533102 0.11111111 0.11111111 ## 3 4 4 16.0436 12.0327 20.0545 0.009066204 0.22222222 0.22222222 ## 4 8 8 24.0654 20.0545 28.0763 0.018132407 0.44444444 0.44444444 ## 5 18 18 32.0872 28.0763 36.0981 0.040797917 1.00000000 1.00000000 ## 6 17 17 40.1090 36.0981 44.1199 0.038531366 0.94444444 0.94444444 ## 7 5 5 48.1308 44.1199 52.1417 0.011332755 0.27777778 0.27777778 ## flipped_aes PANEL group ymin ymax colour fill size linetype alpha ## 1 FALSE 1 -1 0 1 NA grey35 0.5 1 NA ## 2 FALSE 1 -1 0 2 NA grey35 0.5 1 NA ## 3 FALSE 1 -1 0 4 NA grey35 0.5 1 NA ## 4 FALSE 1 -1 0 8 NA grey35 0.5 1 NA ## 5 FALSE 1 -1 0 18 NA grey35 0.5 1 NA ## 6 FALSE 1 -1 0 17 NA grey35 0.5 1 NA ## 7 FALSE 1 -1 0 5 NA grey35 0.5 1 NA The convention used to create the histogram in ggplot is slightly different from that in GeoDa, hence small differences in the bounds of the bins. The summary statistics give the number of observations in each bin (count), the mid-point of the bin (x), and the lower and upper bound for the bin (xmin and xmax). Unlike GeoDa, where the histogram starts at the minimum value and ends at the maximum value, the histogram in ggplot starts with the minimum value at the mid-point of the lowest bin, and the maximum value at the mid-point of the upper bin. Assigning (part of) a graph to an object Any subset of ggplot commands can be assigned to an object, which can save on some typing if the same data set and variables are used for several plots. For example, we assign the main ggplot command with the geom_histogram to the object baseplt. As such, this does not draw anything. Next, we add the different options to the baseplt object, and the graph appears. baseplt &lt;- ggplot(data=nyc.data,aes(kids2009)) + geom_histogram(bins=7) baseplt + xlab(&quot;Percent kids in 2009&quot;) + ylab(&quot;Frequency&quot;) + ggtitle(&quot;Example Histogram&quot;) + theme(plot.title = element_text(hjust = 0.5)) Other descriptive statistics The usual descriptive statistics can be displayed by means of the base R summary command. In principle, we could assign these to an object and then add them to the plot using the geom_text geom, but that is beyond the current scope. We can easily obtain the descriptive statistics provided by GeoDa that are not contained in the R summary command, by means of range, var, and sd, for the range, variance and standard deviation. summary(nyc.data$kids2009) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.00 26.69 33.53 32.07 39.68 48.13 range(nyc.data$kids2009) ## [1] 0.0000 48.1308 var(nyc.data$kids2009) ## [1] 107.535 sd(nyc.data$kids2009) ## [1] 10.36991 Writing the graph to a file In our discussion so far, the graphs are drawn to the screen and then disappear. To save a ggplot graph to a file for publication, there are two ways to proceed. One is the classic R approach, in which first a device is opened, e.g., by means of a pdf command, then the plot commands are entered, and finally the device is turned off by means of dev.off(). Note that it is always a good idea to specify the dimension of the graph (in inches). If not, the results can be unexpected. pdf(&quot;hist.pdf&quot;,height=3,width=3) ggplot(data=nyc.data,aes(kids2009)) + geom_histogram(bins=7) + xlab(&quot;Percent kids in 2009&quot;) + ylab(&quot;Frequency&quot;) + ggtitle(&quot;Example Histogram&quot;) + theme(plot.title = element_text(hjust = 0.5)) dev.off() ## quartz_off_screen ## 2 In addiiton to the standard R approach, ggplot also has the ggsave command, which does the same thing. It requires the name for the output file, but derives the proper format from the file extension. For example, an output file with a png file extension will create a png file, and similarly for pdf, etc. The second argument specifies the plot. It is optional, and when not specified, the last plot is saved. Again, it is a good idea to specify the width and height (in inches). In addition, for raster files, the dots per inch (dpi) can be set as well. The default is 300, which is fine for most use cases, but for high resolution graphs, one can set the dpi to 600, as in the example below. hist.plot &lt;- ggplot(data=nyc.data,aes(kids2009)) + geom_histogram(bins=7) + xlab(&quot;Percent kids in 2009&quot;) + ylab(&quot;Frequency&quot;) + ggtitle(&quot;Example Histogram&quot;) + theme(plot.title = element_text(hjust = 0.5)) ggsave(&quot;hist.png&quot;,plot=hist.plot,width=3,height=3,dpi=600) Saving the graph object An alternative approach to keep a plot object is to assign the plot commands to a variable and then save this to disk, using the standard R command saveRDS. This can later be brought back into an R session using readRDS. To save the plot, we need to specify a file name with an .rds file extension. saveRDS(hist.plot,&quot;hist.rds&quot;) At some later point (or in a different R session), we can then read the object and plot it. Note that we do not need to assign it to the same variable name as before. For example, here we call the graph object newplot. newplot &lt;- readRDS(&quot;hist.rds&quot;) newplot Box plot The box plot, also referred to as Tukey's box and whisker plot, is an alternative way to visualize the distribution of a single variable, with a focus on descriptive statistics such as quartiles and the median.8 We continue our example using the kids2009 variable. We first consider the default option, then move on to various optional settings. Default settings The minimal arguments to create a boxplot are the data set and the x and y variables passed to aes. As mentioned above, the logic behind the graphs in ggplot is two-dimensional, so both x and y need to be specified. The x variable is used to create separate box plots for different subsets of the data. In our simple example, we don't need this feature, so we set the x variable to empty, i.e., &quot; &quot;. The y variable is the actual variable of interest, kids2009. The resulting graph is shown below. ggplot(data=nyc.data,aes(x=&quot;&quot;,y=kids2009)) + geom_boxplot() The box encloses the first and third quartile and shows the median as a thick horizontal bar. The vertical lines show the range of data, not the extent of the fences, as is the case in GeoDa. The single dot at value 0 is the lower outlier. Box plot statistics Unlike what is the case in GeoDa, there is no straightforward way to show the descriptive statistics on the graph. However, we can access the statistics, extract them, and then use text labeling techniques to add them to the plot. We will not pursue that here, but we will illustrate the type of statistics associated with the box plot. As we did for the histogram, we will assign the ggplot object to a variable and then use the layer_data function to extract the information. box.plt &lt;- ggplot(data=nyc.data,aes(x=&quot;&quot;,y=kids2009)) + geom_boxplot() box.dta &lt;- layer_data(box.plt) box.dta ## ymin lower middle upper ymax outliers notchupper notchlower x ## 1 8.6623 26.69425 33.5284 39.6773 48.1308 0 36.2944 30.7624 1 ## flipped_aes PANEL group ymin_final ymax_final xmin xmax xid newx new_width ## 1 FALSE 1 1 0 48.1308 0.625 1.375 1 1 0.75 ## weight colour fill size alpha shape linetype ## 1 1 grey20 white 0.5 NA 19 solid The result is a data frame that contains all the information needed to create the graph. The descriptive statistics require a little clarification. The values for lower and upper are, respectively, the values for the first and third quartile, and middle is the median. ymin (8.6623) and ymax (48.1308) are not the smallest and largest values overall, but the smallest and largest values that fall inside the fences.9 They are the begin and end points of the vertical lines in the plot. outliers contains a list with the outlier values. In our example, there is just one, the value 0 (compare to Figure 18 in the GeoDa workbook). The fences, also sometimes called whiskers, are not contained among the statistics, but they can be easily computed. We illustrate a simple function to accomplish this (note that this function does not implement any error checking and is purely illustrative of the concepts involved). As anything else in R, a function is an object that is assigned to a name. It takes arguments and returns the result. For example, the function box.desc given below takes the layer_data object as the argument box.lyr, extracts the quartiles to compute the interquartile range and to calculate the fences. We also pass the multiplier as mult, with a default value of 1.5 (the default value is set by the equal sign). box.desc &lt;- function(box.lyr,mult=1.5) { # function to computer lower and upper fence in a box plot # box.lyr: a box plot layer_data object # mult: the multiplier for the fence calculation, default = 1.5 iqr &lt;- box.lyr$upper - box.lyr$lower # inter-quartile range upfence &lt;- box.lyr$upper + mult * iqr # upper fence lofence &lt;- box.lyr$lower - mult * iqr # lower fence return(c(lofence,upfence)) } We can now pass the box.dta results to this function to obtain the lower and upper fences. box.desc(box.dta) ## [1] 7.219675 59.151875 These results match the values in the GeoDa workbook. Changing the fence As we did in the GeoDa workbook, we can change the multiplier value to compute the fences. The default is 1.5, but we can set this to 3.0 by means of the coef option. We again assign the plot to an object to both illustrate the graph and the associated statistics. box.plt3 &lt;- ggplot(data=nyc.data,aes(x=&quot;&quot;,y=kids2009)) + geom_boxplot(coef=3) box.plt3 As in the GeoDa example, there are no longer any outliers. In the graph, the lowest point on the vertical line now corresponds with the value of 0. We extract the statistics as before. box.dta3 &lt;- layer_data(box.plt3) box.dta3 ## ymin lower middle upper ymax outliers notchupper notchlower x ## 1 0 26.69425 33.5284 39.6773 48.1308 36.2944 30.7624 1 ## flipped_aes PANEL group ymin_final ymax_final xmin xmax xid newx new_width ## 1 FALSE 1 1 0 48.1308 0.625 1.375 1 1 0.75 ## weight colour fill size alpha shape linetype ## 1 1 grey20 white 0.5 NA 19 solid The statistics are the same, except that the value for ymin is now 0. We double check the results for the fences using our function box.desc, but now pass box.dta3 and set mult=3.0. box.desc(box.dta3,mult=3.0) ## [1] -12.25490 78.62645 Since the lower fence is negative, the value of 0 is no longer an outlier. Fancier options As is, the default box plot is pretty rudimentary. We will illustrate the power of ggplot by adding a number of features to the plot in order to mimic the visual representation given in GeoDa. First, we will remove the label for the x-axis by setting it to &quot;&quot;, and add a title using ggtitle. As we did for the histogram, we will center the title over the graph. To save on some typing, we will assign the ggplot command with its arguments to the variable base.plt and then build the graph by adding layers. First, just the labels. base.plt &lt;- ggplot(data=nyc.data,aes(x=&quot;&quot;,y=kids2009)) base.plt + geom_boxplot() + xlab(&quot;&quot;) + ggtitle(&quot;Example Box Plot&quot;) + theme(plot.title = element_text(hjust=0.5)) Next, we want to give the box plot a color, as in GeoDa. This is accomplished with the color (for the outlines) and fill (for the inside of the box) options to geom_boxplot. In addition, we can give the outlier point a different color by means of outlier.color. For example, setting the color to black, with the fill to purple (if we set both to the same color, we can no longer distinguish the median), and the outlier.color to red, we obtain: base.plt + geom_boxplot(color=&quot;black&quot;,fill=&quot;purple&quot;,outlier.color=&quot;red&quot;) + xlab(&quot;&quot;) + ggtitle(&quot;Example Box Plot&quot;) + theme(plot.title = element_text(hjust=0.5)) So far, the box plots do not show the fences, the way they do in GeoDa. This can be remedied, but not quite in the same way as in GeoDa. In ggplot, the fences are drawn at the location of the extreme values, the ymin and ymax we saw before, and not at the location of the fence cut-off values, as in GeoDa. The fences are obtained from the stat_boxplot function, by passing the geom as errorbar. The result is as shown below. base.plt + geom_boxplot(color=&quot;black&quot;,fill=&quot;purple&quot;,outlier.color=&quot;red&quot;) + stat_boxplot(geom=&quot;errorbar&quot;) + xlab(&quot;&quot;) + ggtitle(&quot;Example Box Plot&quot;) + theme(plot.title = element_text(hjust=0.5)) One final refinement. In GeoDa, the box plot also shows the locations of the actual observations as points on the central axis. We obtain the same effect by adding geom_point with color blue. We draw the points first, and the box plot on top of it, using the layers logic. However, we want to make sure that the central box doesn't mask the points, which it does when the transparency is kept as the default. To accomplish this, we set the alpha level for both points and box plot at 0.5. The result comes as close to the GeoDa visualization as we can get without going overboard. base.plt + geom_point(color=&quot;blue&quot;,alpha=0.5) + geom_boxplot(color=&quot;black&quot;,fill=&quot;purple&quot;,outlier.color=&quot;red&quot;,alpha=0.5) + stat_boxplot(geom=&quot;errorbar&quot;) + xlab(&quot;&quot;) + ggtitle(&quot;Example Box Plot&quot;) + theme(plot.title = element_text(hjust=0.5)) As before, we can write this plot to a file using ggsave, or save the object for future use with saveRDS. Bivariate Analysis: The Scatter Plot The scatter plot shows the relationship between two variables as points with cartesian (x, y) coordinates matching the value for each variable, one on the x-axis, the other on the y-axis. In ggplot the scatter plot is constructed by means of a geom_point. The aesthetics are mapped to the variables for the x and y axis. We mimic the example in the GeoDa workbook and use kids2000 for x, and pubast00 for y. The bare bones scatter plot is obtained as follows: ggplot(data=nyc.data,aes(x=kids2000,y=pubast00)) + geom_point() The graph looks slightly different from the one in GeoDa because of a different aspect ratio (the ratio between the scale used for the y-axis to that for the x-axis). In ggplot, the aspect ratio is set as an argument to the coord_fixed command. We can obtain a scatter plot that more closely mimics the shape of the one in GeoDa by setting the aspect ratio to 55/25, i.e., the ratio of the range on the x-axis over the range of the y-axis in the example in the GeoDa workbook (Figure 24). ggplot(data=nyc.data,aes(x=kids2000,y=pubast00)) + geom_point() + coord_fixed(ratio=55.0/25.0) As we saw before, we can customize the graph further with a title and labels, but we will not pursue that here. The main interest is in bringing out the overall pattern of bivariate association by means of a scatter plot smoother, to which we turn next. Smoothing the scatter plot Scatter plot smoothers are implemented through the geom_smooth command in ggplot. Options include a linear smoother, as method = lm, and a nonlinear loess smoother, as method = loess. Note that the loess smoother is not quite the same as the LOWESS smoother implemented in GeoDa. The latter is not included in ggplot, but can be implemented by means of the stat_plsmo function from the Hmisc package. We consider each smoother in turn. Linear smoother The linear smoother is added to the plot by including the geom_smooth command after the geom_point call. The method is set as lm. In order to better distinguish the fitted line from the points, we set its color to blue, and add a centered title to specify the smoothing algorithm using ggtitle (also, in what follows, we ignore the aspect ratio issue). ggplot(data=nyc.data,aes(x=kids2000,y=pubast00)) + geom_point() + geom_smooth(method=lm, color=&quot;blue&quot;) + ggtitle(&quot;Linear Smoother&quot;) + theme(plot.title = element_text(hjust=0.5)) ## `geom_smooth()` using formula &#39;y ~ x&#39; By default, the linear smoother includes a 95% confidence interval band (the grey band around the blue line). To turn this off, we need to set the option se to FALSE, as below. ggplot(data=nyc.data,aes(x=kids2000,y=pubast00)) + geom_point() + geom_smooth(method=lm, color=&quot;blue&quot;,se=FALSE) + ggtitle(&quot;Linear Smoother&quot;) + theme(plot.title = element_text(hjust=0.5)) ## `geom_smooth()` using formula &#39;y ~ x&#39; Extracting the linear regression results In GeoDa, a linear fit to the scatter plot also yields the results of the regression, such as the coefficients, their standard errors, p-values and an R2 measure of fit. This is not the case in ggplot (by design). However, we can readily obtain these results from the lm function in base R. In its bare minimum, this function takes as arguments a formula and a data set (actually, the latter is not absolutely necessary, depending on how the variables are referred to). In our example, we specify the regression formula as pubast00 ~ kids2000 and the data set as nyc.data.10 Rather than just printing the results of the regression, we assign it to an object, reg1 in our example below. We then apply the summary command to this object, which we assign to yet another object (reg1.sum). When we list the latter, we see a summary of the regression results. reg1 &lt;- lm(pubast00 ~ kids2000, data=nyc.data) reg1.sum &lt;- summary(reg1) reg1.sum ## ## Call: ## lm(formula = pubast00 ~ kids2000, data = nyc.data) ## ## Residuals: ## Min 1Q Median 3Q Max ## -8.5284 -3.7925 -0.2762 3.6696 9.2054 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -5.61829 2.13013 -2.638 0.0109 * ## kids2000 0.39000 0.05645 6.909 6.32e-09 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 4.682 on 53 degrees of freedom ## Multiple R-squared: 0.4739, Adjusted R-squared: 0.4639 ## F-statistic: 47.73 on 1 and 53 DF, p-value: 6.322e-09 The reason for taking what may seem like a circuitous route is that the summary object is simply a list of elements that correspond to aspects of the regression result. Of course, one needs to know what these are called, but, in doubt, a str command will reveal the full structure. str(reg1.sum) ## List of 11 ## $ call : language lm(formula = pubast00 ~ kids2000, data = nyc.data) ## $ terms :Classes &#39;terms&#39;, &#39;formula&#39; language pubast00 ~ kids2000 ## .. ..- attr(*, &quot;variables&quot;)= language list(pubast00, kids2000) ## .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 ## .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. ..$ : chr [1:2] &quot;pubast00&quot; &quot;kids2000&quot; ## .. .. .. ..$ : chr &quot;kids2000&quot; ## .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;kids2000&quot; ## .. ..- attr(*, &quot;order&quot;)= int 1 ## .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. ..- attr(*, &quot;response&quot;)= int 1 ## .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## .. ..- attr(*, &quot;predvars&quot;)= language list(pubast00, kids2000) ## .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;pubast00&quot; &quot;kids2000&quot; ## $ residuals : Named num [1:55] -3.703 -6.222 -8.528 -0.276 -3.061 ... ## ..- attr(*, &quot;names&quot;)= chr [1:55] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ coefficients : num [1:2, 1:4] -5.6183 0.39 2.1301 0.0564 -2.6375 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;kids2000&quot; ## .. ..$ : chr [1:4] &quot;Estimate&quot; &quot;Std. Error&quot; &quot;t value&quot; &quot;Pr(&gt;|t|)&quot; ## $ aliased : Named logi [1:2] FALSE FALSE ## ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;(Intercept)&quot; &quot;kids2000&quot; ## $ sigma : num 4.68 ## $ df : int [1:3] 2 53 2 ## $ r.squared : num 0.474 ## $ adj.r.squared: num 0.464 ## $ fstatistic : Named num [1:3] 47.7 1 53 ## ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;value&quot; &quot;numdf&quot; &quot;dendf&quot; ## $ cov.unscaled : num [1:2, 1:2] 0.206953 -0.005238 -0.005238 0.000145 ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;kids2000&quot; ## .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;kids2000&quot; ## - attr(*, &quot;class&quot;)= chr &quot;summary.lm&quot; For example, we see that the coefficients are in the list element coefficients. They can be extracted by means of the standard $ notation. reg1.sum$coefficients ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -5.6182932 2.13013007 -2.637535 1.093595e-02 ## kids2000 0.3899956 0.05644857 6.908866 6.322337e-09 Similarly, we can extract the R2 and adjusted R2. c(reg1.sum$r.squared,reg1.sum$adj.r.squared) ## [1] 0.4738536 0.4639263 We can now use the text and labeling functionality of ggplot to place these results on the graph. We don't pursue this any further. Loess smoother The default nonlinear smoother in ggplot uses the loess algorithm as a locally weighted regression model. This is similar in spirit to the LOWESS method used in GeoDa, but not the same.11 The implementation is along the same lines as the linear smoother, using geom_smooth, with the only difference that the method is now loess, as shown below. ggplot(data=nyc.data,aes(x=kids2000,y=pubast00)) + geom_point() + geom_smooth(method=loess, color=&quot;blue&quot;) + ggtitle(&quot;Loess Smoother&quot;) + theme(plot.title = element_text(hjust=0.5)) ## `geom_smooth()` using formula &#39;y ~ x&#39; As in any local regression method, an important parameter is how much of the data is used in the local fit, the so-called span. This is typically set to 2/3 of the data by default. A narrower span will yield a smoother that emphasizes local changes. In order to set the span parameter, we use the stat_smooth command. It is in all respects equivalent to geom_smooth, but allows for somewhat more flexibility. For example, we see the difference between the default and a smoother with a span = 0.4. We also turn off the confidence interval by setting se = FALSE. ggplot(data=nyc.data,aes(x=kids2000,y=pubast00)) + stat_smooth(method=&quot;loess&quot;,span=0.4,color=&quot;blue&quot;,se=FALSE) + geom_point() + ggtitle(&quot;Loess Smoother - Span=0.4&quot;) + theme(plot.title = element_text(hjust=0.5)) ## `geom_smooth()` using formula &#39;y ~ x&#39; And even more with a span = 0.2. ggplot(data=nyc.data,aes(x=kids2000,y=pubast00)) + stat_smooth(method=&quot;loess&quot;,span=0.2,color=&quot;blue&quot;,se=FALSE) + geom_point() + ggtitle(&quot;Loess Smoother - Span=0.2&quot;) + theme(plot.title = element_text(hjust=0.5)) ## `geom_smooth()` using formula &#39;y ~ x&#39; LOWESS smoother The LOWESS smoother is not implemented in ggplot, but can be found in the Hmisc package. The approach taken illustrates an alternative way to compute a smoother, similar to the stat_smooth function in ggplot. The latter is equivalent to geom_smooth, but allows for non-standard geoms to visualize the results. We won't pursue that here, but want to point out that this is the spirit in which the function stat_plsmo is implemented. The default is to use a span of 2/3 of the observations (the stat_plsmo command does not have a confidence interval option, so that we do not need to set se). ggplot(data=nyc.data,aes(x=kids2000,y=pubast00)) + stat_plsmo(color=&quot;blue&quot;) + geom_point() + ggtitle(&quot;LOWESS Smoother&quot;) + theme(plot.title = element_text(hjust=0.5)) When compared to the loess results, we can distinguish minor differences. These become more pronounced when setting the span=0.4. ggplot(data=nyc.data,aes(x=kids2000,y=pubast00)) + stat_plsmo(span=0.4,color=&quot;blue&quot;) + geom_point() + ggtitle(&quot;LOWESS Smoother - Span=0.4&quot;) + theme(plot.title = element_text(hjust=0.5)) And even more when setting the span=0.2. ggplot(data=nyc.data,aes(x=kids2000,y=pubast00)) + stat_plsmo(span=0.2,color=&quot;blue&quot;) + geom_point() + ggtitle(&quot;LOWESS Smoother - Span=0.2&quot;) + theme(plot.title = element_text(hjust=0.5)) Putting it all together In GeoDa, it is easy to show both the linear and LOWESS smoother on the same plot. In order to accomplish the same in ggplot, we will use some of the really powerful customization options to create a graph that contains all three smoothing methods. We distinguish between them by setting the color argument in aes to the name of the method, in essence a constant (not a variable). In other words, the color argument to aes is not set to a variable, where it would take a different color depending on the value of that variable, but to a constant, where the color is fixed. This will yield a different color for each of the methods. In order to highlight the curves themselves, we turn off se for lm and loess. The plot will include a legend by default, showing the color with the name of the method. The default title of the legend will be color, i.e., the argument used to reflect the categories. We override this by means of the labs command (for legend labeling), and set color=&quot;Method&quot;. The result is as shown below. ggplot(data=nyc.data,aes(x=kids2000,y=pubast00)) + stat_plsmo(aes(color=&quot;lowess&quot;)) + geom_point() + geom_smooth(aes(color=&quot;lm&quot;),method=lm,se=FALSE) + geom_smooth(aes(color=&quot;loess&quot;),method=loess,se=FALSE) + ggtitle(&quot;Comparison of Smoothing Methods&quot;) + theme(plot.title = element_text(hjust=0.5)) + labs(color=&quot;Method&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; ## `geom_smooth()` using formula &#39;y ~ x&#39; Spatial heterogeneity In GeoDa, it is relatively straightforward to assess the structural stability of the regression coefficients across selected and unselected observations. The selection can be carried out interactively, from the scatter plot or from any other open view, through linking and brushing. The corresponding regression lines and coefficient information are updated dynamically. In R, this is not (yet) quite possible. To illustrate the visualization and assessment of spatial heterogeneity, we will assume we have a way to express the selection as a logical statement. As it turns out, the sub-boroughs in Manhattan have a CODE from 301 to 310, and the sub-boroughs in the Bronx have a CODE from 101 to 110. While this is not exactly the example given in the GeoDa workbook, it is easy enough to replicate. We will proceed by using the mutate command to create a new variable manbronx that matches this selection. For all practical purposes, this gives the same result as if we had selected these observations in a map. Then we will use this classification to create a scatterplot with a separate regression line for the selected and unselected observations, as well as for all the observations, mimicking the behavior of GeoDa (but in a static fashion). Structural breaks in the scatter plot The first step in our process is to create the new variable manbronx using mutate. We also use the if_else command from dplyr to create values for the new variable of Select when the condition is true, and Rest when the condition is false. The condition checks whether the values for CODE are between 300 and 311 (using the symbol &amp; for the logical and), or (using the symbol |) between 100 and 111, the codes for Manhattan and the Bronx. As a check, we list the values for our new variable (since there are only 55 observations, this is not too onerous). nyc.data &lt;- nyc.data %&gt;% mutate(manbronx = if_else((CODE &gt; 300 &amp; CODE &lt; 311) | (CODE &gt; 100 &amp; CODE &lt; 111),&quot;Select&quot;,&quot;Rest&quot;)) nyc.data$manbronx ## [1] &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; ## [9] &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; ## [17] &quot;Rest&quot; &quot;Select&quot; &quot;Select&quot; &quot;Select&quot; &quot;Select&quot; &quot;Select&quot; &quot;Select&quot; &quot;Select&quot; ## [25] &quot;Select&quot; &quot;Select&quot; &quot;Select&quot; &quot;Select&quot; &quot;Select&quot; &quot;Select&quot; &quot;Select&quot; &quot;Select&quot; ## [33] &quot;Select&quot; &quot;Select&quot; &quot;Select&quot; &quot;Select&quot; &quot;Select&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; ## [41] &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; ## [49] &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; &quot;Rest&quot; Next, we create the plot. There are several new elements that we introduce, highlighting the flexibility of ggplot. First, we set the color of the points to correspond with the two categories in the manbronx variable by specifying aes(color=manbronx) for geom_point (i.e., the aesthetic color is mapped to the values of the variable manbronx). Then, we create two separate linear regression lines, one for each category, again by setting aes(color=manbronx) in the geom_smooth command. In order not to overwhelm the graph, we turn the confidence band off (se=FALSE). To construct a regression line for the full sample, we again use geom_smooth, but now we set the color explicitly to black. Since this is outside the aes setting, the regression line is for the full sample. We next set the colors for selected and unselected observations to red and blue, to match the color code in GeoDa (the default setting will have Rest colored red, and Select blue, which is the opposite of the behavior in GeoDa). To accomplish this, we use scale_color_manual to set the values to blue and red, in this order (unselected comes first, since it matches FALSE in the logical statement). Finally, we use labs as before to specify the title for the legend to Selection, and add a centered title. Except for the aspect ratio, the result looks like what one would obtain in GeoDa. ggplot(nyc.data,aes(x=kids2000,y=pubast00)) + geom_point(aes(color=manbronx)) + geom_smooth(aes(color=manbronx),method=lm,se=FALSE) + geom_smooth(method=lm,se=FALSE,color=&quot;black&quot;) + scale_color_manual(values=c(&quot;blue&quot;,&quot;red&quot;)) + ggtitle(&quot;Spatial Heterogeneity&quot;) + theme(plot.title = element_text(hjust=0.5)) + labs(color=&quot;Selection&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; ## `geom_smooth()` using formula &#39;y ~ x&#39; Chow test In GeoDa, a Chow test on the equality of the regression coefficients between the selected and unselected observations is calculated on the fly and shown at the bottom of the scatter plot. This is not supported by ggplot, but we can run separate regressions for each subset using lm. We can also run the Chow test itself, using the chow.test command from the gap package. First, we create two subsets from the nyc.data by means of filter, based on the value of the manbronx variable. We call the two resulting subsets nyc.select and nyc.rest. We double check their size (there should be 20 selected observations and 35 unselected ones) using the dim command. nyc.select &lt;- nyc.data %&gt;% filter(manbronx == &quot;Select&quot;) nyc.rest &lt;- nyc.data %&gt;% filter(manbronx == &quot;Rest&quot;) dim(nyc.select) ## [1] 20 35 dim(nyc.rest) ## [1] 35 35 Next, we carry out two separate regressions, one for each subset, and list the results. reg.select &lt;- lm(pubast00 ~ kids2000,data=nyc.select) reg.rest &lt;- lm(pubast00 ~ kids2000,data=nyc.rest) summary(reg.select) ## ## Call: ## lm(formula = pubast00 ~ kids2000, data = nyc.select) ## ## Residuals: ## Min 1Q Median 3Q Max ## -7.0486 -1.4829 0.3248 2.0625 4.7156 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -4.74763 1.84198 -2.577 0.019 * ## kids2000 0.47225 0.05071 9.313 2.64e-08 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.406 on 18 degrees of freedom ## Multiple R-squared: 0.8281, Adjusted R-squared: 0.8186 ## F-statistic: 86.73 on 1 and 18 DF, p-value: 2.639e-08 summary(reg.rest) ## ## Call: ## lm(formula = pubast00 ~ kids2000, data = nyc.rest) ## ## Residuals: ## Min 1Q Median 3Q Max ## -6.4415 -2.8231 -0.3905 1.9686 8.2359 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -7.01398 3.33123 -2.106 0.042939 * ## kids2000 0.37260 0.08648 4.308 0.000139 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.957 on 33 degrees of freedom ## Multiple R-squared: 0.36, Adjusted R-squared: 0.3406 ## F-statistic: 18.56 on 1 and 33 DF, p-value: 0.0001391 These values match what we would have obtained in GeoDa with the same observations selected. Finally, we implement the Chow test as chow.test. We pass the y and x variables for each subset, in turn. Again, the results are the same as what one would have obtained in GeoDa and suggest a significant difference between the slopes of the two regression lines. chow &lt;- chow.test(nyc.select$pubast00,nyc.select$kids2000, nyc.rest$pubast00,nyc.rest$kids2000) chow ## F value d.f.1 d.f.2 P value ## 1.534013e+01 2.000000e+00 5.100000e+01 6.082099e-06 Use setwd(directorypath) to specify the working directory.↩ Use install.packages(packagename).↩ Note that, strictly speaking, the package is ggplot2, i.e., the second iteration of the ggplot package, but the commands use ggplot. From now on, we will use ggplot to refer to both.↩ In order to obtain the frequency on the vertical axis, the y variable needs to be set to ..density.., as in aes(y = ..density..).↩ For a fuller technical description, see the GeoDa workbook.↩ This can be checked in GeoDa by selecting the corresponding points and checking their value in the Table.↩ A formula in R is the generic way to specify a functional relationship. The dependent variable is on the left hand side of the ~ sign, with an expression for the explanatory variables on the right hand side. The latter are typically separated by +, but in our example, we only have a bivariate relationship. Also, a constant term is included by default.↩ See the GeoDa workbook for further discussion↩ "],
["exploratory-data-analysis-2.html", "Chapter 3 Exploratory Data Analysis 2 Introduction Preliminaries Scatter Plot Matrix Three Variables: Bubble Chart and 3D Scatter Plot True Multivariate EDA: Parallel Coordinate Plot and Conditional Plots", " Chapter 3 Exploratory Data Analysis 2 Introduction This notebook cover the functionality of the Exploratory Data Analysis 2 section of the GeoDa workbook. We refer to that document for details on the methodology, references, etc. The goal of these notes is to approximate as closely as possible the operations carried out using GeoDa by means of a range of R packages. The notes are written with R beginners in mind, more seasoned R users can probably skip most of the comments on data structures and other R particulars. Also, as always in R, there are typically several ways to achieve a specific objective, so what is shown here is just one way that works, but there often are others (that may even be more elegant, work faster, or scale better). For this notebook, we continue to use the socioeconomic data about 55 sub-boroughs in NYC from the GeoDa website. Our goal in this lab is show how to implement exploratory data analysis methods with three or more variables. Objectives After completing the notebook, you should know how to carry out the following tasks: Creating a scatterplot matrix Adding different types of smoothers to a scatter plot matrix Creating a bubble plot Creating a 3d scatter plot Creating a parallel coordinate plot Constructing conditional plots Making graphs interactive R Packages used tidyverse: for general data wrangling (includes readr and dplyr) ggplot2: to draw statistical plots, including conditional plots. We use this rather than base R for increased functionality and more aesthetically pleasing plots (included in tidyverse) GGally: a ggplot add-on package to create a scatterplot matrix and parallel coordinate plot scatterplot3d: to create a static 3d scattter plot plotly: to construct interactive 3d scatter and parallel coordinate plots R Commands used Below follows a list of the commands used in this notebook. For further details and a comprehensive list of options, please consult the R documentation. Base R: setwd, install.packages, library, head, names tidyverse: read_csv, rename, select GGally: ggscatmat, ggpairs, ggparcoord ggplot2: ggplot, geom_point, xlab, ylab, ggtitle, theme, cut_number, facet_grid, geom_smooth, geom_histogram scatterplot3d: scatterplot3d plotly: plot_ly, add_markers, layout Preliminaries Before starting, make sure to have the latest version of R and of packages that are compiled for the matching version of R (this document was created using R 3.5.1 of 2018-07-02). Also, make sure to set a working directory, such that the data set is in the right path.12 Load packages First, we load all the required packages using the library command. If you don't have some of these in your system, make sure to install them first as well as their dependencies.13 You will get an error message if something is missing. If needed, just install the missing piece and everything will work after that. Note that ggplot2 does not need to be loaded separately since it is included in the tidyverse package collection. library(tidyverse) library(GGally) ## Warning: package &#39;GGally&#39; was built under R version 3.6.2 ## Registered S3 method overwritten by &#39;GGally&#39;: ## method from ## +.gg ggplot2 ## ## Attaching package: &#39;GGally&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## nasa library(scatterplot3d) library(plotly) ## Warning: package &#39;plotly&#39; was built under R version 3.6.2 ## ## Attaching package: &#39;plotly&#39; ## The following object is masked from &#39;package:Hmisc&#39;: ## ## subplot ## The following object is masked from &#39;package:ggplot2&#39;: ## ## last_plot ## The following object is masked from &#39;package:stats&#39;: ## ## filter ## The following object is masked from &#39;package:graphics&#39;: ## ## layout library(geodaData) Obtaining the data The data to implement the operations in this workbook are contained in NYC Data on the GeoDa support web site. After the file is downloaded, it must be unzipped (e.g., double click on the file). The nyc folder should be moved to the current working directory for the path names we use below to work correctly. Creating an initial data frame We use the tidyverse function read_csv to read the data into a data frame nyc.data. We could also have used the base R read.csv, but read_csv is a bit more robust and creates a tibble, a data frame with some additional information. As usual, we check the contents of the data frame with a head command. nyc.data &lt;- nyc head(nyc.data) ## # A tibble: 6 x 34 ## bor_subb NAME CODE SUBBOROUGH FORHIS06 FORHIS07 FORHIS08 FORHIS09 FORWH06 ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 501 Nort… 501 North Sho… 37.1 34.0 27.4 29.3 13.3 ## 2 502 Mid-… 502 Mid-Island 28.0 18.1 24.0 31.2 20.1 ## 3 503 Sout… 503 South Sho… 10.7 12.1 9.69 14.7 10.3 ## 4 401 Asto… 401 Astoria 52.1 54.0 54.7 47.8 38.4 ## 5 402 Sunn… 402 Sunnyside… 62.7 69.4 67.1 58.3 37.1 ## 6 403 Jack… 403 Jackson H… 68.5 68.5 66.5 69.2 34.4 ## # … with 25 more variables: FORWH07 &lt;dbl&gt;, FORWH08 &lt;dbl&gt;, FORWH09 &lt;dbl&gt;, ## # HHSIZ1990 &lt;dbl&gt;, HHSIZ00 &lt;dbl&gt;, HHSIZ02 &lt;dbl&gt;, HHSIZ05 &lt;dbl&gt;, ## # HHSIZ08 &lt;dbl&gt;, KIDS2000 &lt;dbl&gt;, KIDS2005 &lt;dbl&gt;, KIDS2006 &lt;dbl&gt;, ## # KIDS2007 &lt;dbl&gt;, KIDS2008 &lt;dbl&gt;, KIDS2009 &lt;dbl&gt;, RENT2002 &lt;dbl&gt;, ## # RENT2005 &lt;dbl&gt;, RENT2008 &lt;dbl&gt;, RENTPCT02 &lt;dbl&gt;, RENTPCT05 &lt;dbl&gt;, ## # RENTPCT08 &lt;dbl&gt;, PUBAST90 &lt;dbl&gt;, PUBAST00 &lt;dbl&gt;, YRHOM02 &lt;dbl&gt;, ## # YRHOM05 &lt;dbl&gt;, YRHOM08 &lt;dbl&gt; Making the variable names compatible As in the previous exercise, we need to make the variable names compatible with their lower case counterparts in the GeoDa Workbook. Again, we will use the tidyverse rename function to turn the all-caps variables into lower case for the examples we will use. As in the GeoDa workbook, we will use the average people per household in 2000 (hhsiz00), the percentage households with children under 18 in 2000 (kids2000), the average number of years lived in the current residence in 2002 (yrhom02), the percentage households receiving public assistance in 2000 (pubast00), and the median rent in 2002 (rent2002). nyc.data &lt;- nyc.data %&gt;% rename(&quot;hhsiz00&quot; = &quot;HHSIZ00&quot;,&quot;kids2000&quot; = &quot;KIDS2000&quot;, &quot;yrhom02&quot;=&quot;YRHOM02&quot;,&quot;pubast00&quot; = &quot;PUBAST00&quot;, &quot;rent2002&quot;=&quot;RENT2002&quot;) names(nyc.data) ## [1] &quot;bor_subb&quot; &quot;NAME&quot; &quot;CODE&quot; &quot;SUBBOROUGH&quot; &quot;FORHIS06&quot; ## [6] &quot;FORHIS07&quot; &quot;FORHIS08&quot; &quot;FORHIS09&quot; &quot;FORWH06&quot; &quot;FORWH07&quot; ## [11] &quot;FORWH08&quot; &quot;FORWH09&quot; &quot;HHSIZ1990&quot; &quot;hhsiz00&quot; &quot;HHSIZ02&quot; ## [16] &quot;HHSIZ05&quot; &quot;HHSIZ08&quot; &quot;kids2000&quot; &quot;KIDS2005&quot; &quot;KIDS2006&quot; ## [21] &quot;KIDS2007&quot; &quot;KIDS2008&quot; &quot;KIDS2009&quot; &quot;rent2002&quot; &quot;RENT2005&quot; ## [26] &quot;RENT2008&quot; &quot;RENTPCT02&quot; &quot;RENTPCT05&quot; &quot;RENTPCT08&quot; &quot;PUBAST90&quot; ## [31] &quot;pubast00&quot; &quot;yrhom02&quot; &quot;YRHOM05&quot; &quot;YRHOM08&quot; Scatter Plot Matrix A scatter plot matrix visualizes the bivariate relationships among several pairs of variables. The individual scatter plots are stacked such that each variable is in turn on the x-axis and on the y-axis. Basic scatter plot matrix A scatter plot matrix is not included in the functionality of ggplot2, but it can be created in a number of ways using the GGally package, which extends ggplot2 with many additional features. Extensive documentation of GGally functionality is available on its Github page. A quick and dirty scatter plot matrix is created by means of the ggscatmat command (detailed documentation is available on the GGally Github page). The ggscatmat function provides pairwise scatter plots in a lower diagonal of the graph, a density graph in the diagonal, and the pairwise correlations in the upper diagonal. This contrasts with GeoDa, where all pairwise scatter plots are given, and the diagonal is populated with a histogram for the individual variable (GeoDa currently does not support density plots). The command is very simple: it takes the data set, the list of variables passed to columns and a few options (color, choice of correlation coefficient). However, it does not seem to contain a way to show a linear or nonlinear smoother. In order to accomplish this, we will need the more powerful ggpairs function (see below). We follow the example in the GeoDa Workbook and use the four variables hhsiz00, kids2000, yrhom02, and pubast00. ggscatmat(nyc.data, columns= c(&quot;hhsiz00&quot;,&quot;kids2000&quot;, &quot;yrhom02&quot;, &quot;pubast00&quot;)) Scatter plot matrix with smoothing An alternative approach that provides much finer control of the graph can be based on the ggpairs function of GGally (see the GGobi Github page for extensive documentation). As in ggscatmat, this function takes the data set as an argument, followed by the variables specified in the columns argument. The lower and upper triangle part of the matrix, and the diagonal are specified by means of the arguments lower, upper, and diag. The values for these arguments must be passed as a list. Default scatter plot matrix First, we illustrate the default setting. We do not need to include the specifics, but they amount to: lower=list(continuous=&quot;points&quot;), for a scatter plot in the lower triangle diag=list(continuous=&quot;densityDiag&quot;), for a density plot on the diagonal upper=list(coninuous='cor'), for a correlation coefficient in the upper diagonal ggpairs(nyc.data, columns=c(&quot;hhsiz00&quot;,&quot;kids2000&quot;, &quot;yrhom02&quot;, &quot;pubast00&quot;)) Pairwise scatter plots In order to obtain a scatter plot in both lower and upper triangles, we set upper = list(continuous=&quot;points&quot;) in the arguments to ggpairs. In addition, to have histograms in the diagonal, set set diag=list(continuous=&quot;barDiag&quot;). ggpairs(nyc.data, columns=c(&quot;hhsiz00&quot;,&quot;kids2000&quot;, &quot;yrhom02&quot;, &quot;pubast00&quot;), upper=list(continuous=&quot;points&quot;),diag=list(continuous=&quot;barDiag&quot;)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Scatter plot matrix with linear smoother At this point, we can add a linear smoother by specifying list(continuous=&quot;smooth&quot;) instead of continuous=&quot;points&quot; for both upper and lower parameters (back with the default density plot on the diagonal). ggpairs(nyc.data, columns=c(&quot;hhsiz00&quot;,&quot;kids2000&quot;, &quot;yrhom02&quot;, &quot;pubast00&quot;), upper=list(continuous=&quot;smooth&quot;),lower=list(continuous=&quot;smooth&quot;)) Scatter plot matrix with loess smoother The ggpairs function also supports a nonlinear loess smoother, but not the LOWESS smoother implemented in GeoDa. In order to include the latter, it would be necessary to create a custom function to pass as an argument to the upper and lower settings. This is beyond our current scope (again, see the GGobi Github page for techical details). Similarly, if one wanted finer control over the parameters of the smoothing method (like setting a span), this must be implemented by means of a custom function. The loess smoother is passed in the same way as the linear smoother, as an argument to continuous = &quot;smooth_loess&quot;. ggpairs(nyc.data, columns=c(&quot;hhsiz00&quot;,&quot;kids2000&quot;, &quot;yrhom02&quot;, &quot;pubast00&quot;), upper=list(continuous=&quot;smooth_loess&quot;),lower=list(continuous=&quot;smooth_loess&quot;)) The ggpairs function has many other customization features to deal with axis labels, titles, etc., which we do not further pursue here. As mentioned above, just about anything can be included as a custom function using the ggplot API (for example, using the wrap functionality documented on the Github pages). Finally, as already alluded to earlier, linking and brushing are not included in the functionality of ggplot. The graphs can be made interactive by means of the plotly package, which we illustrate below for the 3D scatter plot. Three Variables: Bubble Chart and 3D Scatter Plot Bubble chart The bubble chart augments the scatter plot with a third dimension, the size of the point (or, bubble). Optionally, a fourth dimension can be added as the color of the point, but this quickly becomes difficult to discern. In GeoDa, the four dimensions are available by default, with the third and fourth set to the same variable. In ggplot, this is accomplished by setting a third and potentially fourth aesthetic for size and col to a variable. We first illustrate a bubble chart using the variable kids2000 for the x-axis, pubast00 for the y-axis, and rent2002 for the bubble size. These are passed as arguments to aes. This is followed by the geom_point geom. As before, we can add labels for the x and y axis, as well as a title. ggplot(data=nyc.data,aes(x=kids2000,y=pubast00,size=rent2002)) + geom_point() + xlab(&quot;Percent HH with kids&quot;) + ylab(&quot;Percent HH with public assistance&quot;) + ggtitle(&quot;Bubble Chart&quot;) + theme(plot.title = element_text(hjust = 0.5)) Now, we also introduce the col as rent2002. ggplot(data=nyc.data,aes(x=kids2000,y=pubast00,size=rent2002,col=rent2002)) + geom_point() + xlab(&quot;Percent HH with kids&quot;) + ylab(&quot;Percent HH with public assistance&quot;) + ggtitle(&quot;Bubble Chart&quot;) + theme(plot.title = element_text(hjust = 0.5)) Note that we used the default color bar for the color argument. There is a wide scope for customization of legends and color schemes in ggplot, which is beyond the current scope. In a nutshell, in order to fully mimic the graphs in GeoDa, one would need to use one of the ColorBrewer color schemes, which are available as an option in ggplot. 3D Scatter Plot Basic 3D scatter plot The three-dimensional scatter plot is a simple generalization of the two-dimensional case by creating a graph that projects a 3D cube onto the two-dimensional screen (or paper), as a perspective plot. This is not (currently) supported by ggplot, so we resort to the specialized package scatterplot3d (see Ligges and Mächler 2003). This is an older package that predates the layered logic of ggplot, and instead uses the approach taken in the base R plot commands. A rudimentary plot follows from the scatterplot3d function to which the variables for the three dimensions are passed as arguments to x, y, and z. In contrast to ggplot, there is no data argument, but the variables must be specified using the standard $ notation. We again use the variables kids2000, pubast00, and rent2002. In addition, we spiff up the graph a bit by adding a main title, as well as titles for xlab, ylab, and zlab. In addition, we set the symbol to a filled circle (the default is a hollow circle), using the base R pch = 20 argument, and color it red (color = &quot;red&quot;), as in the GeoDa Workbook example. The result is as given below. scatterplot3d(x = nyc.data$kids2000, y = nyc.data$pubast00, z = nyc.data$rent2002, main = &quot;NYC 3D Scatterplot&quot;, xlab = &quot;Percent HH with kids&quot;, ylab = &quot;Percent HH with public assistance&quot;, zlab = &quot;Median rent&quot;, pch = 20, color = &quot;red&quot;) Plotly in a nutshell The static 3D scatter plot is fine as a traditional graph, but is not that useful for data exploration. To that effect, we will illustrate some functionality contained in the plotly package. This package forms an R interface to the extensive open source Javascript graphing library of the same name, plotly.js, which leverages the extensive collection of D3 charts. The plotly package is just one of several interfaces to plotly. Another commonly used one is Plotly.py for Python. The functionality in plotly is huge, and much more than we can cover here. We refer to the many web resources for further details. An excellent overview is given in Carson Sievert's plotly for R book, especially in Chapter 2, The Plotly Cookbook. There are two main ways to create interactive graphs using plotly. One is to pass the usual arguments to the plot_ly command, which has its own Grammar of Graphics syntax. This uses the concept of traces, which is similar to the layers in ggplot. The second way uses the ggplotly command, which takes one or more ggplot objects and makes them interactive. We will not cover the second approach, but it is a fairly straightforward way to make any of our earlier ggplot graphs interactive. The basic arguments to plot_ly are the same as for ggplot, i.e., the data set, and the axes (x, y, and for 3D, z). The variable names are passed in a slightly different way, and use the formula notation, with the variable name prefaced by the ~ symbol. So, for example, if the x-axis would map to the variable kids2000, that would be specified as x = ~kids2000, and similarly for the other axes. Just like ggplot, plotly has a layered approach to constructing a graph, but instead of using a plus sign to separate the layers, a pipe command, %&gt;% is used. Also, the various options for customization are passed to the respective arguments as a list. We will illustrate the basics of plot_ly by constructing a 3D scatter plot for the same three variables as above. Interacting with the 3D scatter plot There are several ways to interact with a plot in plotly, but here we will illustrate some basic functionality to zoom in, zoom out, and rotate the 3D cube, similar to what is available in GeoDa. We start with a bare bones graph. We pass the data set and the three variables to the plot_ly function. Since the default trace is a scatter plot, this is all we really need to specify. plot_ly(nyc.data, x = ~kids2000, y = ~pubast00, z = ~rent2002) ## No trace type specified: ## Based on info supplied, a &#39;scatter3d&#39; trace seems appropriate. ## Read more about this trace type -&gt; https://plot.ly/r/reference/#scatter3d ## No scatter3d mode specifed: ## Setting the mode to markers ## Read more about this attribute -&gt; https://plot.ly/r/reference/#scatter-mode There are warnings, but it works. Basically, since we did not specify a trace type, the default scatter3d is applied, which is exactly what we wanted. Also, since no mode is specified, the default is set to markers. The moment we move the pointer over the graph, a number of small icons appear in the right-hand top. These correspond to different types of interactions that can be carried out. Before we proceed with those, however, we move the pointer to one of the points. The hovering functionality (here left to the default of listing all data dimensions) will list the values for x, y and z in a small box, and draw the projections to each of the axes. The second left-most icon at the top of the graph invokes the Zoom functionality. Now, moving the pointer back and forth makes the cube smaller or larger. Other interesting options are the Orbital rotation and Turntable rotation, the two icons to the right of the home symbol. Both options move the cube around as the pointer changes position. The left-most icon allows a static version of the plot to be downloaded as a png file. Next, we illustrate a very simple way to add some further information to the graph. First, we use add_markers to turn the observation points red. Note how the argument marker is set equal to a list to pass the needed color parameter. The add_markers command follows the initial plot_ly setting after a %&gt;% pipe symbol. A final touch is to set titles for the axes, by means of the layout command and the scene option, again after a pipe symbol. The titles are set by means of a list command for each of the three xaxis, yaxis, and zaxis. At this point, when we execute the command, there are no more warnings. Also, we can interact with the graph in the same way as before. plot_ly(nyc.data, x = ~kids2000, y = ~pubast00, z = ~rent2002) %&gt;% add_markers(marker = list(color=&quot;red&quot;)) %&gt;% layout(scene = list(xaxis = list(title = &quot;Percent HH with kids&quot;), yaxis = list(title = &quot;Percent HH with public assistance&quot;), zaxis = list(title = &quot;Median rent&quot;))) True Multivariate EDA: Parallel Coordinate Plot and Conditional Plots True multivariate EDA deals with situations where more than three variables are considered. We follow the GeoDa Workbook and illustrate the Parallel Coordinate Plot, or PCP, and conditional plots. For the former, we again need to resort to GGally, but for the latter, we can exploit the facet_wrap and facet_grid functions of ggplot. In addition, we can turn these plots into interactive graphs by means of the plotly functionality. Parallel Coordinate Plot (PCP) PCP in GGally The PCP is implemented in the ggparcoord function of GGally. However, its implementation does not follow the regular columns specification we used above for the scatterplot matrix. Instead of passing a list of variable names, the actual column numbers of the variables in the data frame must be specified (but those may be in any order). An easy, though not very elegant way to deal with this is to create a subset of the data for those variables to be plotted, and then exploit the default of columns = 1:ncol(data). In other words, we don't have to specify the columns argument at all. In the example below, we use the same four variables as in the GeoDa Workbook: kids2000, rent2002, pubast00, and yrhom02. We first select those from the nyc.data set to create a subset we call pcp.vars. Then, we pass this subset as the argument to data in ggparcoord. The result is a fairly rudimentary PCP, with the axes organized vertically (in GeoDa, they are horizontal). Many customizations are possible, for which detailed options can be found in the documentation pages. vars &lt;- c(&quot;kids2000&quot;,&quot;rent2002&quot;,&quot;pubast00&quot;,&quot;yrhom02&quot;) pcp.vars &lt;- select(nyc.data,vars) ## Note: Using an external vector in selections is ambiguous. ## ℹ Use `all_of(vars)` instead of `vars` to silence this message. ## ℹ See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;. ## This message is displayed once per session. ggparcoord(data = pcp.vars) PCP in plotly In plotly, the PCP functionality in implemented as the type = &quot;parcoords&quot;. This is passed as the second argument to the plot_ly function (the first argument, as usual, is the data set, nyc.data). The axes of the PCP are specified through the dimensions argument. As is the case in other plot_ly examples, they are passed as a list. In this instance, this is actually a list of lists, one for each axis. In each of these lists, we include a label for the axis, and a variable as the argument to the values parameter. As before, we need to use a formula format for the variables and precede their names with the ~ symbol. plot_ly(nyc.data,type = &quot;parcoords&quot;, dimensions = list( list(label = &quot;Kids&quot;, values = ~kids2000), list(label = &quot;Public Assistance&quot;, values = ~pubast00), list(label = &quot;Rent&quot;, values = ~rent2002), list(label = &quot;Stable&quot;, values = ~yrhom02) ) ) Once we move the pointer over the graph, a few icons appear on the top right (but fewer than for the 3D scatter plot). The interaction with the graph is not that intuitive, but once you know what to look for, it is quite powerful. The easiest way to proceed is to click on one of the axes: with the cross hair + symbol placed at any location along an axis, clicking will change the color and select the observations (lines) covered by the small vertical bar (the pointer will turn into an arrow that points up or down, depending on the direction of the selection). Clicking the cross hair in another position on the same axis turns the selection off. A second interactive feature allows one to change the order of the axes. For example, if we move the pointer to the top of the Stable axis, it changes from a cross hair to a double sided arrow &lt;-&gt;. Pressing down on the pointer now lets us move this axis to the left, e.g., to become the third axis. This can be done even while certain observations are selected. Several options for customization of the PCP graph can be found in the plotly documentation for parcoords. Conditional Plots Conditional plots are a major feature of the functionality of ggplot, where they are referred to as facetting, or small multiples. This is implemented in the facet_wrap and facet_grid functions. The main difference between the two approaches is that facet_grid is explicitly two-dimensional. In that aspect, it is the closest matches to the conditional plot design in GeoDa. There is one major difference between the approach taken in GeoDa and that in ggplot. In GeoDa, the conditioning variables are typically continuous, and different types of classifications can be applied to them to obtain the actual condition. For example, in the GeoDa Workbook illustration, the variables hhsiz00 and yrhom02 are used as conditioning variables for respectively, the x-axis and the y-axis. A classification such as quantiles (e.g., 3 or 2 in the GeoDa Workbook examples) yields the categories for the sub-plots. In ggplot, the conditioning is based on a categorical variable that needs to be available in the data set. The facetting formula does not evaluate functions, so the conditioning categories need to be computed beforehand. There are three so-called helper functions to make this easy: cut_interval, cut_width, and cut_number. The closest to the median (2 quantiles) conditioning illustrated in the GeoDa Workbook is the cut_number function. We pass the variable, e.g., hhziz00, and the number of categories, say n = 2. This creates the new variable as an R factor, giving the intervals that resulted from the cut. For example, we create a new variable cut.hhsiz using a quantile classification with two categories (as in the GeoDa Workbook, the variable will be split on the median value), by setting n=2. We need to use the $ notation to ensure that the new variable is added to the relevant data set. Since we only have 55 observations, we can easily list the full set of values to verify. Internally, they are stored as factors (hence, the summary of the Levels at the end of the listing). nyc.data$cut.hhsiz &lt;- cut_number(nyc.data$hhsiz00,n=2) nyc.data$cut.hhsiz ## [1] (2.72,3.2] [1.57,2.72] (2.72,3.2] [1.57,2.72] [1.57,2.72] (2.72,3.2] ## [7] (2.72,3.2] [1.57,2.72] [1.57,2.72] [1.57,2.72] [1.57,2.72] (2.72,3.2] ## [13] (2.72,3.2] [1.57,2.72] (2.72,3.2] (2.72,3.2] [1.57,2.72] [1.57,2.72] ## [19] [1.57,2.72] [1.57,2.72] [1.57,2.72] [1.57,2.72] [1.57,2.72] [1.57,2.72] ## [25] [1.57,2.72] [1.57,2.72] (2.72,3.2] (2.72,3.2] (2.72,3.2] (2.72,3.2] ## [31] (2.72,3.2] (2.72,3.2] [1.57,2.72] (2.72,3.2] [1.57,2.72] [1.57,2.72] ## [37] (2.72,3.2] (2.72,3.2] (2.72,3.2] (2.72,3.2] [1.57,2.72] [1.57,2.72] ## [43] [1.57,2.72] (2.72,3.2] (2.72,3.2] (2.72,3.2] (2.72,3.2] (2.72,3.2] ## [49] (2.72,3.2] [1.57,2.72] (2.72,3.2] (2.72,3.2] [1.57,2.72] [1.57,2.72] ## [55] [1.57,2.72] ## Levels: [1.57,2.72] (2.72,3.2] And, similarly for cut.yrhom: nyc.data$cut.yrhom &lt;- cut_number(nyc.data$yrhom02,n=2) nyc.data$cut.yrhom ## [1] [8.22,12.4] (12.4,16.1] (12.4,16.1] (12.4,16.1] (12.4,16.1] (12.4,16.1] ## [7] [8.22,12.4] (12.4,16.1] (12.4,16.1] (12.4,16.1] (12.4,16.1] [8.22,12.4] ## [13] (12.4,16.1] (12.4,16.1] (12.4,16.1] (12.4,16.1] (12.4,16.1] [8.22,12.4] ## [19] (12.4,16.1] [8.22,12.4] [8.22,12.4] [8.22,12.4] [8.22,12.4] (12.4,16.1] ## [25] (12.4,16.1] (12.4,16.1] (12.4,16.1] [8.22,12.4] [8.22,12.4] [8.22,12.4] ## [31] [8.22,12.4] [8.22,12.4] (12.4,16.1] [8.22,12.4] (12.4,16.1] [8.22,12.4] ## [37] (12.4,16.1] (12.4,16.1] [8.22,12.4] [8.22,12.4] [8.22,12.4] [8.22,12.4] ## [43] [8.22,12.4] [8.22,12.4] [8.22,12.4] [8.22,12.4] [8.22,12.4] [8.22,12.4] ## [49] [8.22,12.4] (12.4,16.1] (12.4,16.1] [8.22,12.4] (12.4,16.1] (12.4,16.1] ## [55] [8.22,12.4] ## Levels: [8.22,12.4] (12.4,16.1] If we compare the breakpoints to the ones in Figure 34 of the Workbook, we see that they are close, but not exactly the same, i.e., 2.72 vs. 2.703 in GeoDa, and 12.4 vs. 12.368. More precisely, upon closer examination, we find that for cut.hhsiz, the lower group has 28 observations vs. 27 in GeoDa. Since we have so few data points, this may lead to slight differences in the graphs. At this point, we can set up the conditioning in the facet_grid function, expressed as a formula, with the row conditioning variable first. Note that the row conditioning variable is the y-axis in GeoDa, and the column conditioning variable is the x-axis. For example, with our new categories cut.hhsiz and cut.yrhom, this would be facet_grid(cut.yrhom ~ cut.hhsiz). One final aspect is how the categories are ordered in the graph. The default (as.table=TRUE) is to have the highest category in the lower-right corner. In order to mimic the organization in GeoDa, we set as.table=FALSE. This results in the highest category being in the upper-right corner. We now illustrate this for a conditional scatter plot and a conditional histogram. Conditional scatter plot We replicate the example in the GeoDa Workbook and condition a scatter plot with kids2000 on the x-axis and pubast00 on the y-axis. We set these two variables as x and y in the aes argument of ggplot. Next, we specify the geom as geom_point, for the default scatter plot. Finally, we add the facet_grid command. ggplot(data=nyc.data,aes(x=kids2000,y=pubast00)) + geom_point() + facet_grid(cut.yrhom ~ cut.hhsiz,as.table=FALSE) We can add a linear smoother by means of geom_smooth(method=&quot;lm&quot;): ggplot(data=nyc.data,aes(x=kids2000,y=pubast00)) + geom_point() + geom_smooth(method=&quot;lm&quot;) + facet_grid(cut.yrhom ~ cut.hhsiz,as.table=FALSE) ## `geom_smooth()` using formula &#39;y ~ x&#39; We can also add a loess smoother by means of geom_smooth(method=&quot;loess&quot;): ggplot(data=nyc.data,aes(x=kids2000,y=pubast00)) + geom_point() + geom_smooth(method=&quot;loess&quot;) + facet_grid(cut.yrhom ~ cut.hhsiz,as.table=FALSE) ## `geom_smooth()` using formula &#39;y ~ x&#39; As is the case for all graphs in ggplot, many further customizations can be added, but we do not consider that further. Conditional histogram We conclude with a conditional histogram for the variable pubast00. The principle is the same as before. The only difference is that now only one variable needs to be specified in aes, and the geom_histogram is used. As we did earlier, we set the bins=7 (the default of 30 is not appropriate in this example). The resulting graph differs slightly from the example in the GeoDa Workbook due to different bin widths. With some customization, they can be made to look exactly the same, but we won't pursue that here. ggplot(data=nyc.data,aes(pubast00)) + geom_histogram(bins=7) + facet_grid(cut.yrhom ~ cut.hhsiz,as.table=FALSE) Use setwd(directorypath) to specify the working directory.↩ Use install.packages(packagename).↩ "],
["basic-mapping.html", "Chapter 4 Basic Mapping Introduction Preliminaries Basic Choropleth Mapping Common Map Classifications Extreme Value Maps Mapping Categorical Variables Conditional Map Cartogram", " Chapter 4 Basic Mapping Introduction This notebook covers the functionality of the Basic Mapping section of the GeoDa workbook. We refer to that document for details on the methodology, references, etc. The goal of these notes is to approximate as closely as possible the operations carried out using GeoDa by means of a range of R packages. The notes are written with R beginners in mind, more seasoned R users can probably skip most of the comments on data structures and other R particulars. Also, as always in R, there are typically several ways to achieve a specific objective, so what is shown here is just one way that works, but there often are others (that may even be more elegant, work faster, or scale better). For this notebook, we will continue to use the socioeconomic data for 55 New York City sub-boroughs from the GeoDa website. Objectives After completing the notebook, you should know how to carry out the following tasks (some of these were also covered in the spatial data handling notes): Reading and loading a shapefile Creating choropleth maps for different classifications Customizing choropleth maps Selecting appropriate color schemes Calculating and plotting polygon centroids Composing conditional maps Creating a cartogram R Packages used sf: to manipulate simple features tmap: to create and customize choropleth maps RColorBrewer: to select color schemes cartogram: to construct a cartogram R Commands used Below follows a list of the commands used in this notebook. For further details and a comprehensive list of options, please consult the R documentation. Base R: setwd, install.packages, library, summary, quantile, function, unname, vector, floor, ceiling, cut, as.factor, as.character, as.numeric, which, length, rev, unique sf: st_read, st_crs, plot, st_centroid, st_write, st_set_geometry(NULL) tmap: tm_shape, tm_polygons, tm_fill, tm_borders, tm_layout, tmap_mode, tm_basemap, tmap_save, tm_dots, tm_facets RColorBrewer: brewer.pal, display.brewer.pal cartogram: cartogram_dorling, cartogram_cont, cartogram_ncont Preliminaries Before starting, make sure to have the latest version of R and of packages that are compiled for the matching version of R (this document was created using R 3.5.1 of 2018-07-02). Also, make sure to set a working directory.14 We will use a relative path to the working directory to read the data set. Load packages First, we load all the required packages using the library command. If you don't have some of these in your system, make sure to install them first as well as their dependencies.15 You will get an error message if something is missing. If needed, just install the missing piece and everything will work after that. library(sf) library(tmap) library(RColorBrewer) library(cartogram) library(geodaData) Obtaining the data The data set used to implement the operations in this workbook is the same as the one we used for exploratory data analysis. The variables are contained in NYC Data on the GeoDa support web site. After the file is downloaded, it must be unzipped (e.g., double click on the file). The nyc folder should be moved to the current working directory for the path names we use below to work correctly. We use the st_read command from the sf package to read in the shape file information. This provides a brief summary of the geometry of the layer, such as the path (your path will differ), the driver (ESRI Shapefile), the geometry type (MULTIPOLYGON), bounding box and projection information. The latter is contained in the proj4string information. nyc.bound &lt;- nyc_sf The projection in question is the ESRI projection 102718, NAD 1983 stateplane New York Long Island fips 3104 feet. It does not have an EPSG code (see the spatial data handling notes for further details on projections), but it has a valid proj4string. So, as long as we don't change anything, we should be OK. We can double check the projection information with st_crs: st_crs(nyc.bound) ## Coordinate Reference System: ## EPSG: 2263 ## proj4string: &quot;+proj=lcc +lat_1=41.03333333333333 +lat_2=40.66666666666666 +lat_0=40.16666666666666 +lon_0=-74 +x_0=300000.0000000001 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=us-ft +no_defs&quot; As we saw in the spatial data handling notes, we can create a quick map using the sf plot command. This will result in a choropleth map for the first few variables in the data frame. plot(nyc.bound) ## Warning: plotting the first 9 out of 34 attributes; use max.plot = 34 to plot ## all Basic Choropleth Mapping We now turn to the choropleth mapping functionality included in the tmap package. We have already covered some functionality of tmap in the spatial data handling notes. Here, we will explore some further customizations. The tmap package is extremely powerful, and there are many features that we do not cover. Detailed information on tmap functionality can be found at tmap documentation. In addition, several extensive examples are listed in the review in the Journal of Statistical Software by Tennekes (2018). Another useful resource is the chapter on mapping in Lovelace, Nowosad, and Muenchow's Geocomputation with R book. Default settings We have already seen (in the spatial data handling notes) that tmap uses the same layered logic as ggplot. The initial command is tm_shape, which specifies the geography to which the mapping is applied. This is followed by a number of tm_* options that select the type of map and several optional customizations. We follow the example in the GeoDa Workbook and start with a basic choropleth map of the rent2008 variable. In tmap there are two ways to create a choropleth map. The simplest one, which we have already seen, is to use the tm_polygons command with the variable name as the argument (under the hood, this is the value for the col parameter). In our example, the map is created with two commands, as shown below. The color coding corresponds to style = &quot;pretty&quot;, which is the default when the classification breaks are not set explicitly, and the default values are used (see the discussion of map classifications below). tm_shape(nyc.bound) + tm_polygons(&quot;rent2008&quot;) The tm_polygons command is a wrapper around two other functions, tm_fill and tm_borders. tm_fill controls the contents of the polygons (color, classification, etc.), while tm_borders does the same for the polygon outlines. For example, using the same shape (but no variable), whe obtain the outlines of the sub-boroughs from the tm_borders command. tm_shape(nyc.bound) + tm_borders() Similarly, we obtain a choropleth map without the polygon outlines when we just use the tm_fill command. tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;) When we combine the two commands, we obtain the same map as with tm_polygons (this illustrates how in R one can often obtain the same result in a number of different ways). tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;) + tm_borders() An extensive set of options is available to customize the appearance of the map. A full list is given in the documentation page for tm_fill. In what follows, we briefly consider the most common ones. Color palette The range of colors used to depict the spatial distribution of a variable is determined by the palette. The palette is an argument to the tm_fill function. Several built-in palettes are contained in tmap. For example, using palette = &quot;Reds&quot; would yield the following map for our example. tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,palette=&quot;Reds&quot;) + tm_borders() Under the hood, &quot;Reds&quot; refers to one of the color schemes supported by the RColorBrewer package (see below). 4.0.0.1 Custom color palettes In addition to the built-in palettes, customized color ranges can be created by specifying a vector with the desired colors as anchors. This will create a spectrum of colors in the map that range between the colors specified in the vector. For instance, if we used c(&quot;red&quot;, &quot;blue&quot;), the color spectrum would move from red to purple, then to blue, with in between shades. In our example: tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,palette=c(&quot;red&quot;,&quot;blue&quot;)) + tm_borders() Not exactly a pretty picture. In order to mimic the diverging scale used in many of GeoDa's extreme value maps, we insert &quot;white&quot; in between red and blue (but see the next section for a better approach). tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,palette=c(&quot;red&quot;,&quot;white&quot;,&quot;blue&quot;)) + tm_borders() Better, but still not quite there. ColorBrewer A preferred approach to select a color palette is to chose one of the schemes contained in the RColorBrewer package. These are based on the research of cartographer Cynthia Brewer (see the colorbrewer2 web site for details). ColorBrewer makes a distinction between sequential scales (for a scale that goes from low to high), diverging scales (to highlight how values differ from a central tendency), and qualitative scales (for categorical variables). For each scale, a series of single hue and multi-hue scales are suggested. In the RColorBrewer package, these are referred to by a name (e.g., the &quot;Reds&quot; palette we used above is an example). The full list is contained in the RColorBrewer documentation. There are two very useful commands in this package. One sets a color palette by specifying its name and the number of desired categories. The result is a character vector with the hex codes of the corresponding colors. For example, we select a sequential color scheme going from blue to green, as BuGn, by means of the command brewer.pal, with the number of categories (6) and the scheme as arguments. The resulting vector contains the HEX codes for the colors. pal &lt;- brewer.pal(6,&quot;BuGn&quot;) pal ## [1] &quot;#EDF8FB&quot; &quot;#CCECE6&quot; &quot;#99D8C9&quot; &quot;#66C2A4&quot; &quot;#2CA25F&quot; &quot;#006D2C&quot; Using this palette in our map yields the following result. tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,palette=&quot;BuGn&quot;) + tm_borders() The command display.brewer.pal allows us to explore different color schemes before applying them to a map. For example: display.brewer.pal(6,&quot;BuGn&quot;) Legend There are many options to change the formatting of the legend entries through the legend.format argument. We refer to the tm_fill documentation for specific details. Often, the automatic title for the legend is not that attractive, since it is simply the variable name. This can be customized by setting the title argument to tm_fill. For example, keeping all the other settings to the default, we change the legend to Rent in 2008. tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,title=&quot;Rent in 2008&quot;) + tm_borders() Another important aspect of the legend is its positioning. This is handled through the tm_layout function. This function has a vast number of options, as detailed in the documentation. There are also specialized subsets of layout functions, focused on specific aspects of the map, such as tm_legend, tm_style and tm_format. We illustrate the positioning of the legend. The default is to position the legend inside the map. Often, this default solution is appropriate, but sometimes further control is needed. The legend.position argument to the tm_layout function takes a vector of two string variables that determine both the horizontal position (&quot;left&quot;, &quot;right&quot;, or &quot;center&quot;) and the vertical position (&quot;top&quot;, &quot;bottom&quot;, or &quot;center&quot;). For example, if we would want to move the legend to the lower-right position (clearly inferior to the default solution), we would use the following set of commands. tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,title=&quot;Rent in 2008&quot;) + tm_borders() + tm_layout(legend.position = c(&quot;right&quot;, &quot;bottom&quot;)) There is also the option to position the legend outside the frame of the map. This is accomplished by setting legend.outside to TRUE (the default is FALSE), and optionally also specify its position by means of legend.outside.position. The latter can take the values &quot;top&quot;, &quot;bottom&quot;, &quot;right&quot;, and &quot;left&quot;. For example, to position the legend outside and on the right, would be accomplished by the following commands. tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,title=&quot;Rent in 2008&quot;) + tm_borders() + tm_layout(legend.outside = TRUE, legend.outside.position = &quot;right&quot;) We can also customize the size of the legend, its alignment, font, etc. We refer to the documentation for specifics. While there is no obvious way to show the number of observations in each category (as is the case in GeoDa), tmap has an option to add a histogram to the legend. This is accomplished by setting legend.hist=TRUE in the tm_fill command. Further customization is possible, but is not covered here. tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,title=&quot;Rent in 2008&quot;,legend.hist=TRUE) + tm_borders() + tm_layout(legend.outside = TRUE, legend.outside.position = &quot;right&quot;) Title Another functionality of the tm_layout function is to set a title for the map, and specify its position, size, etc. For example, we can set the title, the title.size and the title.position as in the example below (for details, see the tm_layout documentation). We made the font size a bit smaller (0.8) in order not to overwhelm the map, and positioned it in the bottom right-hand corner. tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,title=&quot;Rent in 2008&quot;) + tm_borders() + tm_layout(title = &quot;Rent 2008 NYC Sub-Boroughs&quot;, title.size = 0.8, title.position = c(&quot;right&quot;,&quot;bottom&quot;)) To have a title appear on top (or on the bottom) of the map, rather than inside (the default), we need to set the main.title argument of the tm_layout function, with the associated main.title.position, as illustrated below (with title.size set to 1.5 to have a larger font). tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,title=&quot;Rent in 2008&quot;) + tm_borders() + tm_layout(main.title = &quot;Rent 2008 NYC Sub-Boroughs&quot;, title.size = 1.5,main.title.position=&quot;center&quot;) Border options So far, we have not specified any arguments to the tm_borders function. Common options are the color for the border lines (col), their thickness (lwd) and the type of line (lty). The line type is a base R functionality and can be set by specifying a string (such as &quot;solid&quot;, &quot;dashed&quot;, &quot;dotted&quot;, etc.), or the internal code (e.g., 1 for solid, 2 for dashed, 3 for dotted). To illustrate this, we set the borders to blue, with a line width of 2.0 and use a dotted line. tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,title=&quot;Rent in 2008&quot;) + tm_borders(col=&quot;blue&quot;,lwd=2,lty=3) Interactive base map The default mode in tmap is plot, i.e., the standard plotting environment in R to draw a map on the screen or to a device (e.g., a pdf file). There is also an interactive mode, which builds upon leaflet to add a basemap and interact with the map through zooming and identification of individual observations. The interactive mode is referred to as view. We switch between modes by means of the tmap_mode command. tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing There are a number of different ways in which a basemap can be added. The current preferred approach is through the tm_basemap command. This takes two important arguments. One is the name of the server. A number of basemaps are supported (and no doubt, that number will increase over time), but we will illustrate the OpenStreetMap option. A second argument is the degree of transparency, or alpha level. This can also be set for the map itself through tm_fill. In practice, one typically needs to experiment a bit to find the right balance between the information in the choropleth map and the background. In the example below, we set the alpha level for the main map to 0.7, and for the base layer to 0.5. When we move the pointer over the polygons, their ID value is shown. A click on a location also gives the value for the variable that is being mapped. Zooming and panning are supported as well. In addition, it is possible to stack several layers, but we won't pursue that here. tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,title=&quot;Rent in 2008&quot;,alpha=0.7) + tm_borders() + tm_basemap(server=&quot;OpenStreetMap&quot;,alpha=0.5) Before we proceed, we turn the mode back to plot. tmap_mode(&quot;plot&quot;) ## tmap mode set to plotting Saving a map as a file So far, we have only plotted the map to the screen or an interactive widget. In order to save the map as an output, we first assign the result of a series of tmap commands to a variable (an object). We can then save this object by means of the tmap_save function.16 This function takes the map object as the argument tm and the output file name as the argument filename. The default output is a png file. Other formats are obtained by including the proper file extension. There are many other options in this command, such as specifying the height, width, and dpi. Details can be found in the list of options. For example, we assign our rudimentary default map to the variable mymap and then save that to the file mymap.png. mymap &lt;- tm_shape(nyc.bound) + tm_fill(&quot;kids2000&quot;) + tm_borders() tmap_save(tm = mymap, filename = &quot;mymap.png&quot;) ## Map saved to mymap.png ## Resolution: 2100 by 1500 pixels ## Size: 7 by 5 inches (300 dpi) Shape centers GeoDa has functionality invoked from a map window to map or save shape centers, i.e., mean centers and centroids. The st_centroid function is part of sf (there is no obvious counterpart to the mean center functionality). It creates a point simple features layer and contains all the variables of the original layer. nycentroid &lt;- st_centroid(nyc.bound) ## Warning in st_centroid.sf(nyc.bound): st_centroid assumes attributes are ## constant over geometries of x summary(nycentroid) ## bor_subb name code subborough ## Min. :101.0 Length:55 Min. :101.0 Length:55 ## 1st Qu.:204.5 Class :character 1st Qu.:204.5 Class :character ## Median :218.0 Mode :character Median :218.0 Mode :character ## Mean :274.4 Mean :274.4 ## 3rd Qu.:403.5 3rd Qu.:403.5 ## Max. :503.0 Max. :503.0 ## forhis06 forhis07 forhis08 forhis09 ## Min. :10.70 Min. :10.37 Min. : 9.689 Min. :14.66 ## 1st Qu.:29.61 1st Qu.:28.92 1st Qu.:28.182 1st Qu.:28.28 ## Median :39.72 Median :39.21 Median :39.567 Median :35.99 ## Mean :39.22 Mean :38.33 Mean :37.764 Mean :37.46 ## 3rd Qu.:44.61 3rd Qu.:45.30 3rd Qu.:45.496 3rd Qu.:45.14 ## Max. :69.52 Max. :69.40 Max. :69.341 Max. :69.16 ## forwh06 forwh07 forwh08 forwh09 ## Min. : 0.00 Min. : 0.00 Min. : 0.00 Min. : 0.00 ## 1st Qu.:14.26 1st Qu.:14.56 1st Qu.:14.30 1st Qu.:13.57 ## Median :21.18 Median :21.10 Median :21.39 Median :19.69 ## Mean :24.36 Mean :23.54 Mean :22.67 Mean :21.98 ## 3rd Qu.:31.53 3rd Qu.:29.78 3rd Qu.:31.38 3rd Qu.:27.98 ## Max. :60.36 Max. :59.64 Max. :59.11 Max. :56.89 ## hhsiz1990 hhsiz00 hhsiz02 hhsiz05 ## Min. :1.560 Min. :1.574 Min. :1.532 Min. :1.544 ## 1st Qu.:2.428 1st Qu.:2.445 1st Qu.:2.234 1st Qu.:2.271 ## Median :2.716 Median :2.718 Median :2.568 Median :2.567 ## Mean :2.635 Mean :2.639 Mean :2.505 Mean :2.471 ## 3rd Qu.:2.937 3rd Qu.:2.929 3rd Qu.:2.812 3rd Qu.:2.682 ## Max. :3.376 Max. :3.202 Max. :3.087 Max. :3.106 ## hhsiz08 kids2000 kids2005 kids2006 ## Min. :1.544 Min. : 8.382 Min. : 8.708 Min. : 8.683 ## 1st Qu.:2.203 1st Qu.:30.301 1st Qu.:27.871 1st Qu.:26.215 ## Median :2.488 Median :38.228 Median :35.763 Median :36.524 ## Mean :2.424 Mean :36.040 Mean :34.353 Mean :33.847 ## 3rd Qu.:2.665 3rd Qu.:42.773 3rd Qu.:42.152 3rd Qu.:41.174 ## Max. :3.222 Max. :55.367 Max. :50.872 Max. :51.911 ## kids2007 kids2008 kids2009 rent2002 ## Min. : 8.067 Min. : 8.004 Min. : 0.00 Min. : 0.0 ## 1st Qu.:27.366 1st Qu.:27.843 1st Qu.:26.69 1st Qu.: 750.0 ## Median :35.414 Median :33.883 Median :33.53 Median : 800.0 ## Mean :33.801 Mean :33.212 Mean :32.07 Mean : 944.4 ## 3rd Qu.:40.290 3rd Qu.:40.610 3rd Qu.:39.68 3rd Qu.:1000.0 ## Max. :51.502 Max. :49.716 Max. :48.13 Max. :2500.0 ## rent2005 rent2008 rentpct02 rentpct05 ## Min. : 0.0 Min. : 0 Min. : 0.00 Min. : 0.00 ## 1st Qu.: 897.5 1st Qu.:1000 1st Qu.:13.27 1st Qu.:13.04 ## Median : 990.0 Median :1100 Median :21.11 Median :22.59 ## Mean :1045.9 Mean :1257 Mean :22.01 Mean :22.08 ## 3rd Qu.:1100.0 3rd Qu.:1362 3rd Qu.:29.49 3rd Qu.:30.51 ## Max. :2500.0 Max. :2900 Max. :43.38 Max. :40.88 ## rentpct08 pubast90 pubast00 yrhom02 ## Min. : 0.00 Min. :23.89 Min. : 0.8981 Min. : 8.216 ## 1st Qu.:15.48 1st Qu.:62.38 1st Qu.: 3.3860 1st Qu.:11.264 ## Median :23.70 Median :75.44 Median : 6.8781 Median :12.391 ## Mean :23.41 Mean :71.53 Mean : 8.4372 Mean :12.251 ## 3rd Qu.:31.50 3rd Qu.:84.59 3rd Qu.:11.5369 3rd Qu.:13.160 ## Max. :47.38 Max. :96.65 Max. :23.4318 Max. :16.124 ## yrhom05 yrhom08 geometry ## Min. : 8.583 Min. : 8.278 POINT :55 ## 1st Qu.:11.268 1st Qu.:10.846 epsg:2263 : 0 ## Median :12.217 Median :12.274 +proj=lcc ...: 0 ## Mean :12.273 Mean :12.058 ## 3rd Qu.:13.288 3rd Qu.:13.001 ## Max. :16.627 Max. :15.425 We can now exploit the layered logic of tm_map to first draw the outlines of the sub-boroughs using tm_borders, followed by tm_dots for the point layer. The tm_dots command is a specialized version of tm_symbols, which has a very large set of options. We use two simple options: size=0.2 to make the points a little larger than the default, and col to set the color to red. tm_shape(nyc.bound) + tm_borders() + tm_shape(nycentroid) + tm_dots(size=0.2,col=&quot;red&quot;) A close examination of the map reveals that the centroid locations can be problematic for non-convex polygons. We can save the centroid point layer as a shape file by means of the st_write function we saw earlier (in the spatial data handling notes). st_write(nycentroid, &quot;nyc_centroids&quot;, driver = &quot;ESRI Shapefile&quot;) ## Writing layer `nyc_centroids&#39; to data source `nyc_centroids&#39; using driver `ESRI Shapefile&#39; ## Writing 55 features with 34 fields and geometry type Point. Common Map Classifications The statistical aspects of a choropleth map are expressed through the map classification that is used to convert observations for a continuous variable into a small number of bins, similar to what is the case for a histogram. Different classifications reveal different aspects of the spatial distribution of the variable. In tmap, the classification is selected by means of the style option in tm_fill. So far, we have used the default, which is set to pretty. The latter is a base R function to compute a sequence of roughly equally spaced values. Note that the number of intervals that results is not necessariy equal to n (the preferred number of classes), which can seem confusing at first.17 There are many classification types available in tmap, which each correspond to either a base R function, or to a custom expression contained in the classIntervals functionality. In this section, we review the quantile map, natural breaks map, and equal intervals map, and also illustrate how to set custom breaks with their own labels. For a detailed discussion of the methodological issues associated with these classifications, we refer to the GeoDa Workbook. We continue to use the same example for rent2008. Quantile map A quantile map is obtained by setting style=&quot;quantile&quot; in the tm_fill command. The number of categories is taken from the n argument, which has a default value of 5. So, for example, using this default will yield a quintile map with five categories (we specify the type of map in the title through tm_layout). tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,title=&quot;Rent in 2008&quot;,style=&quot;quantile&quot;) + tm_borders() + tm_layout(title = &quot;Quintile Map&quot;, title.position = c(&quot;right&quot;,&quot;bottom&quot;)) We follow the example in the GeoDa Workbook and illustrate a quartile map. This is created by specifying n=4, for four categories with style=&quot;quantile&quot;. The rest of the commands are the same as before. tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,title=&quot;Rent in 2008&quot;,n=4,style=&quot;quantile&quot;) + tm_borders() + tm_layout(title = &quot;Quartile Map&quot;, title.position = c(&quot;right&quot;,&quot;bottom&quot;)) Natural breaks map A natural breaks map is obtained by specifying the style = &quot;jenks&quot; in tm_fill. All the other options are as before. Again, we illustrate this for four categories, with n=4. tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,title=&quot;Rent in 2008&quot;,n=4,style=&quot;jenks&quot;) + tm_borders() + tm_layout(title = &quot;Natural Breaks Map&quot;, title.position = c(&quot;right&quot;,&quot;bottom&quot;)) Equal intervals map An equal intervals map for four categories is obtained by setting n=4, and style=&quot;equal&quot;. The resulting map replicates the result in GeoDa. tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,title=&quot;Rent in 2008&quot;,n=4,style=&quot;equal&quot;) + tm_borders() + tm_layout(title = &quot;Equal Intervals Map&quot;, title.position = c(&quot;right&quot;,&quot;bottom&quot;)) Custom breaks For all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the breaks argument to the tm_fill function. To illustrate this, we mimic the example in the GeoDa Workbook, which uses the variable kids2000. The classification results in six categories. Unlike what is the case in the GeoDa Category Editor, in tmap the breaks include a minimum and maximum (in GeoDa, only the break points themselves need to be specified). As a result, in order to end up with n categories, n+1 elements must be specified in the breaks option (the values must be in increasing order). It is always good practice to get some descriptive statistics on the variable before setting the break points. For kids2000, a summary command yields the following results. summary(nyc.bound$kids2000) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.382 30.301 38.228 36.040 42.773 55.367 Following the example in the GeoDa workbook, we set break points at 20, 30, 40, 45, and 50. In addition, we also need to include a minimum and maximum, which we set at 0 and 65. Our breaks vector is thus c(0,20,30,40,45,50,60). We also use the same color palette as in the GeoDa Workbook. This is a sequential scale, referred to as &quot;YlOrBr&quot; in ColorBrewer. The resulting map is identical to the one obtained with GeoDa. tm_shape(nyc.bound) + tm_fill(&quot;kids2000&quot;,title=&quot;Percentage Kids&quot;,breaks=c(0,20,30,40,45,50,60),palette=&quot;YlOrBr&quot;) + tm_borders() + tm_layout(title = &quot;Custom Breaks Map&quot;, title.position = c(&quot;right&quot;,&quot;bottom&quot;)) Extreme Value Maps In addition to the common map classifications, GeoDa also supports three types of extreme value maps: a percentile map, box map, and standard deviation map. For details on the rationale and methodology behind these maps, we refer to the GeoDa Workbook. Of the three extreme value maps, only the standard deviation map is included as a style in tmap. To create the other two, we will need to use the custom breaks functionality. Ideally, we should create an additional style, but that's beyond the scope of these notes. The three extreme value maps in GeoDa share the same color palette. This is a diverging scale with 6 categories, corresponding to the ColorBrewer &quot;RdBu&quot; scheme. We can illustrate the associated colors with a display.brewer.pal command. display.brewer.pal(6,&quot;RdBu&quot;) This seems OK at first sight, but the ranking is the opposite of the one used in GeoDa. Therefore, to reverse the order, we will need to preface the name with a &quot;-&quot; in the palette specification. Percentile map The percentile map is a special type of quantile map with six specific categories: 0-1%,1-10%, 10-50%,50-90%,90-99%, and 99-100%. We can obtain the corresponding breakpoints by means of the base R quantile command, passing an explicit vector of cumulative probabilities as c(0,.01,.1,.5,.9,.99,1). Note that the begin and endpoint need to be included, as we already pointed out in the discussion of the generic custom break points. A percentile map is then created by passing the resulting break points to tm_fill. In addition, we can also pass labels for the new categories, using the labels option, for example, as labels = c(&quot;&lt; 1%&quot;, &quot;1% - %10&quot;, &quot;10% - 50%&quot;, &quot;50% - 90%&quot;,&quot;90% - 99%&quot;, &quot;&gt; 99%&quot;). Extracting a variable from an sf data frame There is one catch, however. When variables are extracted from an sf dataframe, the geometry is extracted as well. For mapping and spatial manipulation, this is the expected behavior, but many base R functions cannot deal with the geometry. Specifically, the quantile function gives an error. For example, this is illustrated when we extract the variable rent2008 and then apply the quantile function. percent &lt;- c(0,.01,.1,.5,.9,.99,1) var &lt;- nyc.bound[&quot;rent2008&quot;] quantile(var,percent) ## Error in as.data.frame.default(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors): cannot coerce class &#39;c(&quot;XY&quot;, &quot;MULTIPOLYGON&quot;, &quot;sfg&quot;)&#39; to a data.frame We remove the geometry by means of the st_set_geometry(NULL) operation in sf, but it still doesn't work. var &lt;- nyc.bound[&quot;rent2008&quot;] %&gt;% st_set_geometry(NULL) quantile(var,percent) ## Error in `[.data.frame`(x, order(x, na.last = na.last, decreasing = decreasing)): undefined columns selected As it happens, the selection of the variable returns a data frame, not a vector, and the quantile function doesn't know which column to use. We make that explicit by taking the first column (and all rows), as [,1]. Now, it works. var &lt;- nyc.bound[&quot;rent2008&quot;] %&gt;% st_set_geometry(NULL) quantile(var[,1],percent) ## 0% 1% 10% 50% 90% 99% 100% ## 0 0 950 1100 2140 2873 2900 Since we will have to carry out this kind of transformation any time we want to carry out some computation on a variable, we create a simple helper function to extract the variable vname from the simple features data frame df. We have added one extra feature, i.e., we remove the name of the vector by means of unname. get.var &lt;- function(vname,df) { # function to extract a variable as a vector out of an sf data frame # arguments: # vname: variable name (as character, in quotes) # df: name of sf data frame # returns: # v: vector with values (without a column name) v &lt;- df[vname] %&gt;% st_set_geometry(NULL) v &lt;- unname(v[,1]) return(v) } A percentile map function To create a percentile map for the variable rent2008 from scratch, we proceed in four steps. First, we set the cumulative percentages to compute the quantiles, in the vector percent. Second, we extract the variable as a vector using our function get.var. Next, we compute the breaks with the quantile function. Finally, we create the map using tm_fill with the breaks and labels option, and the palette set to &quot;-RdBu&quot; (to reverse the default order of the colors). percent &lt;- c(0,.01,.1,.5,.9,.99,1) var &lt;- get.var(&quot;rent2008&quot;,nyc.bound) bperc &lt;- quantile(var,percent) tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,title=&quot;Rent in 2008&quot;,breaks=bperc,palette=&quot;-RdBu&quot;, labels=c(&quot;&lt; 1%&quot;, &quot;1% - %10&quot;, &quot;10% - 50%&quot;, &quot;50% - 90%&quot;,&quot;90% - 99%&quot;, &quot;&gt; 99%&quot;)) + tm_borders() + tm_layout(title = &quot;Percentile Map&quot;, title.position = c(&quot;right&quot;,&quot;bottom&quot;)) We can summarize this in a simple function. Note that this is just a bare bones implementation. Additional arguments could be passed to customize various features of the map (such as the title, legend positioning, etc.), but we leave that for an exercise. Also, the function assumes (and does not check) that get.var is available. For general use, this should not be assumed. The minimal arguments we can pass are the variable name (vnam), the data frame (df), a title for the legend (legtitle, set to NA as default, the same default as in tm_fill), and an optional title for the map (mtitle, set to Percentile Map as the default). percentmap &lt;- function(vnam,df,legtitle=NA,mtitle=&quot;Percentile Map&quot;){ # percentile map # arguments: # vnam: variable name (as character, in quotes) # df: simple features polygon layer # legtitle: legend title # mtitle: map title # returns: # a tmap-element (plots a map) percent &lt;- c(0,.01,.1,.5,.9,.99,1) var &lt;- get.var(vnam,df) bperc &lt;- quantile(var,percent) tm_shape(df) + tm_fill(vnam,title=legtitle,breaks=bperc,palette=&quot;-RdBu&quot;, labels=c(&quot;&lt; 1%&quot;, &quot;1% - %10&quot;, &quot;10% - 50%&quot;, &quot;50% - 90%&quot;,&quot;90% - 99%&quot;, &quot;&gt; 99%&quot;)) + tm_borders() + tm_layout(title = mtitle, title.position = c(&quot;right&quot;,&quot;bottom&quot;)) } We illustrate this for the rent2008 variable, without a legend title. percentmap(&quot;rent2008&quot;,nyc.bound) Box map To create a box map, we proceed largely along the same lines as for the percentile map, using the custom breaks specification. However, there is a complication. The break points for the box map vary depending on whether lower or upper outliers are present. In essence, a box map is an augmented quartile map, with an additional lower and upper category. When there are lower outliers, then the starting point for the breaks is the minimum value, and the second break is the lower fence. In contrast, when there are no lower outliers, then the starting point for the breaks will be the lower fence, and the second break is the minimum value (there will be no observations that fall in the interval between the lower fence and the minimum value). The same complication occurs at the upper end of the distribution. When there are upper outliers, then the last value for the breaks is the maximum value, and the next to last value is the upper fence. In contrast, when there are no upper outliers, then the last value is the upper fence, and the next to last is the maximum. As such, however, this is not satisfactory, because the default operation of the cuts is to have the interval.closure=&quot;left&quot;. This implies that the observation with the maximum value (the break point for the last category) will always be assigned to the outlier category when there are in fact no outliers. Similarly, the observation with the minimum value (the break point for the second category) will be assigned to the first group. We therefore create a small function to deal with these complications and compute the break points for a box map. Then we create a function for the box map along the same lines as for the percentile map. Computing the box map break points We follow the logic outlined above to create the 7 breakpoints (for the 6 categories) for the box map. We handle the problem with the interval closure by rounding the maximum value such that its observation will always fall in the proper category. We need to distinguish between a minimum and a maximum. For the former, we use the floor function, for the latter, the ceiling function. Our function boxbreaks returns the break points. It reuses the same calculations that we already exploited to compute the fences for the box plot. It takes a vector of observations and optionally a value for the multiplier as arguments (the default multiplier is 1.5). The function first gets the quartile values from the quantile function (the default is to compute quartiles, so we do not have to pass cumulative probabilities). Next, we calculate the upper and lower fence for the given multiplier value. The break points vector (bb) is initialized as a zero vector with 7 values (one more than the number of categories). The middle three values (3 to 5) will correspond to the first quartile, median, and third quartile. The first two values are allocated depending on whether there are lower outliers, and the same for the last two values. boxbreaks &lt;- function(v,mult=1.5) { # break points for box map # arguments: # v: vector with observations # mult: multiplier for IQR (default 1.5) # returns: # bb: vector with 7 break points # compute quartile and fences qv &lt;- unname(quantile(v)) iqr &lt;- qv[4] - qv[2] upfence &lt;- qv[4] + mult * iqr lofence &lt;- qv[2] - mult * iqr # initialize break points vector bb &lt;- vector(mode=&quot;numeric&quot;,length=7) # logic for lower and upper fences if (lofence &lt; qv[1]) { # no lower outliers bb[1] &lt;- lofence bb[2] &lt;- floor(qv[1]) } else { bb[2] &lt;- lofence bb[1] &lt;- qv[1] } if (upfence &gt; qv[5]) { # no upper outliers bb[7] &lt;- upfence bb[6] &lt;- ceiling(qv[5]) } else { bb[6] &lt;- upfence bb[7] &lt;- qv[5] } bb[3:5] &lt;- qv[2:4] return(bb) } We illustrate this for rent2008, taking advantage of our get.var function. var &lt;- get.var(&quot;rent2008&quot;,nyc.bound) boxbreaks(var) ## [1] 0.00 456.25 1000.00 1100.00 1362.50 1906.25 2900.00 In our example, there are both lower and upper outliers. As a result, the first and last values in the vector are, respectively, the minimum and maximum, and positions 2 and 6 are taken by the lower and upper fence. A box map function Our function boxmap is designed along the same lines as the percentile map. It assumes that both get.var and boxbreaks are available. Again, the minimal arguments we can pass are the variable name (vnam), the data frame (df), a title for the legend (legtitle, set to NA as default, the same default as in tm_fill), and an optional title for the map (mtitle, set to Percentile Map as the default). In addition, we also need to pass a value for the multiplier (mult, needed by boxbreaks). boxmap &lt;- function(vnam,df,legtitle=NA,mtitle=&quot;Box Map&quot;,mult=1.5){ # box map # arguments: # vnam: variable name (as character, in quotes) # df: simple features polygon layer # legtitle: legend title # mtitle: map title # mult: multiplier for IQR # returns: # a tmap-element (plots a map) var &lt;- get.var(vnam,df) bb &lt;- boxbreaks(var) tm_shape(df) + tm_fill(vnam,title=legtitle,breaks=bb,palette=&quot;-RdBu&quot;, labels = c(&quot;lower outlier&quot;, &quot;&lt; 25%&quot;, &quot;25% - 50%&quot;, &quot;50% - 75%&quot;,&quot;&gt; 75%&quot;, &quot;upper outlier&quot;)) + tm_borders() + tm_layout(title = mtitle, title.position = c(&quot;right&quot;,&quot;bottom&quot;)) } Illustrated for the rent2008 variable: boxmap(&quot;rent2008&quot;,nyc.bound) 4.0.1 Standard deviation map A standard deviation map is included in tmap as style=&quot;sd&quot;. We follow the GeoDa Workbook and return to the rent2008 variable for our examples. Apart from setting the style, we also specify the palette=&quot;-RdBu&quot;. This yields the same map as GeoDa. tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;,title=&quot;Rent in 2008&quot;,style=&quot;sd&quot;,palette=&quot;-RdBu&quot;) + tm_borders() + tm_layout(title = &quot;Standard Deviation Map&quot;, title.position = c(&quot;right&quot;,&quot;bottom&quot;)) Mapping Categorical Variables In the GeoDa Workbook, the mapping of categorical variables is illustrated by extracting the classifications from a map as integer values. There doesn't seem to be an obvious way to do this for a tmap element. Instead, we will resort to the base R function cut to create integer values for a classification. We will then turn these into factors to be able to use the style=&quot;cat&quot; option in tm_fill. Note that it is important to have the variable as a factor. When integer values are used as such, the resulting map follows a standard sequential classification. Creating categories We use the same example variables as in the GeoDa Workbook and create box map categories for kids2000 and pubast00. We first extract the variable, using our get.var function. var &lt;- get.var(&quot;kids2000&quot;,nyc.bound) Next, we construct a vector with the boxmap breakpoints using our boxbreaks function. vbreaks &lt;- boxbreaks(var) vbreaks ## [1] 8.38150 11.59360 30.30115 38.22780 42.77285 56.00000 61.48040 We verify the treatment of lower and upper fences by comparing the result to a summary. summary(var) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 8.382 30.301 38.228 36.040 42.773 55.367 We observe that the first value in the breaks vector is the minimum, indicating lower outliers. However, the last value is larger than the maximum, indicating the lack of upper outliers. Consequently, our integer codes will not include the value 6. We use the boxmap breaks to create a classification by means of the cut function. We pass the vector of observations and the vector of breaks and then specify some important options. The default in cut is to create labels for the categories as strings that show the lower and upper bound. Instead, we want to have a numeric code, so we set the option labels=FALSE (the opposite of the default). Also, we want to make sure that the mininum value is included if it is the lowest value (the default is that it would not be) by setting include.lowest=TRUE. The result is a vector of integer codes. Since we only have 55 observations, we can list the result (note the absence of a code of 6). vcat &lt;- cut(var,breaks=vbreaks,labels=FALSE,include.lowest=TRUE) vcat ## [1] 4 3 4 2 2 4 4 3 2 3 3 5 4 3 5 4 4 1 2 1 1 2 2 3 3 3 4 5 5 5 5 5 3 5 2 3 4 3 ## [39] 5 5 2 2 3 5 5 5 5 4 4 2 4 4 3 3 2 Finally, we need to add the new variable as a factor to the simple features layer, using the standard $ notation. We call the new variable kidscat, as in the GeoDa Workbook. We could (and should) turn this whole operation into a function, but we leave that as an exercise for now. nyc.bound$kidscat &lt;- as.factor(vcat) Unique value map We are now in a position to create a unique value map for the new variable kidscat. All the options are as before, except that style=&quot;cat&quot; and we set palette=&quot;Paired&quot; to replicate the map in GeoDa. tm_shape(nyc.bound) + tm_fill(&quot;kidscat&quot;,style=&quot;cat&quot;,palette=&quot;Paired&quot;) + tm_borders() + tm_layout(title = &quot;Unique Value Map&quot;, title.position = c(&quot;right&quot;,&quot;bottom&quot;)) Co-location map A special case of a map for categorical variables is a so-called co-location map, implemented in GeoDa. This map shows the values for those locations where two categorical variables take on the same value (it is up to the user to make sure the values make sense). Further details are given in the GeoDa Workbook. To replicate a co-location map in R takes a little bit of work. First we need to identify the locations that match. Then, in order to make a map that makes sense, we need to make sure we pick the right colors from the color palette. We follow the example in the GeoDa Workbook and create a co-location map for the box map categories for kids2000 and pubast00. We already created the former, as the new variable kidscat. We still need to create a categorical variable for the latter. We proceed in the same way as before to add the variable asstcat to the nyc.bound layer. var2 &lt;- get.var(&quot;pubast00&quot;,nyc.bound) vb2 &lt;- boxbreaks(var2) vcat2 &lt;- cut(var2,breaks=vb2,labels=FALSE,include.lowest=TRUE) nyc.bound$asstcat &lt;- as.factor(vcat2) A unique value map illustrates the spatial distribution of the categories. tm_shape(nyc.bound) + tm_fill(&quot;asstcat&quot;,style=&quot;cat&quot;,palette=&quot;Paired&quot;) + tm_borders() + tm_layout(title = &quot;Unique Value Map&quot;, title.position = c(&quot;right&quot;,&quot;bottom&quot;)) Identifying the matching locations We find the positions of the matching locations by checking the equality between the variables kidscat and asstcat (note that we need to specify the data frame, using the $ notation to select the variable). Since there is no guarantee that the two variables have the same number of categories (in fact, kidscat has categories 1-5, whereas asstcat has 2-5), a direct comparison of the factors might fail. Therefore, we first turn the factors into numeric values, and then do the comparison. In order to make sure that the resulting integers are the correct categories, we must first convert the factors into strings, using as.character. For example, since our second variable starts at level 2, a simple as.numeric will turn that into 1 (since it is the first level). Finally, we use the which command to find the positions of the observations where the condition is TRUE. There are 25 such locations (out of 55). v1 &lt;- as.numeric(as.character(nyc.bound$kidscat)) v2 &lt;- as.numeric(as.character(nyc.bound$asstcat)) ch &lt;- v1 == v2 locmatch &lt;- which(ch == TRUE) locmatch ## [1] 5 8 9 17 22 23 28 29 30 31 32 33 34 35 37 39 40 44 45 48 49 51 52 53 54 length(locmatch) ## [1] 25 Since the two variables use the same coding scheme, and the matching locations have the same value, we can use either one to extract a categorical value for the unique value map. We start by initializing a vector of zeros equal in length to the number of observations. We will use a code of 0 for those locations without a match. We next set the vector locations with matching values (the indices contained in locmatch) to their corresponding values in kidscat. Finally, we add the new vector to the simple features layer as a factor. matchcat &lt;- vector(mode=&quot;numeric&quot;,length=length(nyc.bound$kidscat)) matchcat[locmatch] &lt;- nyc.bound$kidscat[locmatch] nyc.bound$colocate &lt;- as.factor(matchcat) Customizing the color palette We continue to follow the GeoDa Workbook example and use the color palette for a box map (since both categorical variables were derived from a box map). This is the &quot;RdBu&quot; color scheme in RColorBrewer. However, as we pointed out before, the color order needs to be reversed. We accomplish this with the rev function. In addition, we need to include a color for the mismatch category, which we have set to 0. We take a shade of white for those locations, more specifically, so-called white smoke, with a HEX code of &quot;#F5F5F5&quot;. We add this value in front of the other codes and print the result as a check. pal &lt;- rev(brewer.pal(6,&quot;RdBu&quot;)) pal &lt;- c(&quot;#F5F5F5&quot;,pal) pal ## [1] &quot;#F5F5F5&quot; &quot;#2166AC&quot; &quot;#67A9CF&quot; &quot;#D1E5F0&quot; &quot;#FDDBC7&quot; &quot;#EF8A62&quot; &quot;#B2182B&quot; If we use the full palette, we get the following result. tm_shape(nyc.bound) + tm_fill(&quot;colocate&quot;,style=&quot;cat&quot;,palette=pal) + tm_borders() + tm_layout(title = &quot;Co-Location Map&quot;, title.position = c(&quot;right&quot;,&quot;bottom&quot;)) Upon closer examination of the example in the GeoDa Workbook, we see that the color is shifted down for all categories. For example, the color for category 2 should be light blue, not dark blue. To fix this aspect of the legend, we identify those codes that appear in the colocate vector. This is a bit complicated, since those values are factors. As before, first we need to turn them into strings using as.character, and then we turn this into integers by means of as.numeric. We extract the codes that are present with the unique operator. Next, we need to add 1 to those values to be able to refer to positions in a vector (positions start at 1, not 0). Finally, we extract the proper subset of the color palette. mcats &lt;- unique(as.numeric(as.character(nyc.bound$colocate))) mcats &lt;- mcats+1 colpal &lt;- pal[mcats] We now use this palette in our categorical map to completely replicate the result in GeoDa. tm_shape(nyc.bound) + tm_fill(&quot;colocate&quot;,style=&quot;cat&quot;,palette=colpal) + tm_borders() + tm_layout(title = &quot;Co-Location Map&quot;, title.position = c(&quot;right&quot;,&quot;bottom&quot;)) Conditional Map A conditional map, or facet map, or small multiples, is created by the tm_facets command. This largely follows the logic of the facet_grid command in ggplot that we covered in the EDA notes. An extensive set of options is available to customize the facet maps. An in-depth coverage of all the subtleties is beyond our scope (details can be found on the tm_facets documentation page) Whereas in GeoDa, the conditions can be based on the original variables, here, we need to first create the conditioning variables as factors. We follow the same procedure as before, but here we use the standard cut function to create the factors. We specify the breaks argument as 2. We follow the example in the GeoDa Workbook and use hhsiz00 and forhis08 as the conditioning variables. The new factors are cut.hhsiz and cut.forhis. They are added to the nyc.bound layer using the familiar $ operation. For example, for hhsiz00: nyc.bound$cut.hhsiz &lt;- cut(nyc.bound$hhsiz00,breaks=2) nyc.bound$cut.hhsiz ## [1] (2.39,3.2] (2.39,3.2] (2.39,3.2] (2.39,3.2] (2.39,3.2] (2.39,3.2] ## [7] (2.39,3.2] (2.39,3.2] (1.57,2.39] (2.39,3.2] (2.39,3.2] (2.39,3.2] ## [13] (2.39,3.2] (2.39,3.2] (2.39,3.2] (2.39,3.2] (2.39,3.2] (1.57,2.39] ## [19] (1.57,2.39] (1.57,2.39] (1.57,2.39] (1.57,2.39] (1.57,2.39] (2.39,3.2] ## [25] (1.57,2.39] (2.39,3.2] (2.39,3.2] (2.39,3.2] (2.39,3.2] (2.39,3.2] ## [31] (2.39,3.2] (2.39,3.2] (1.57,2.39] (2.39,3.2] (1.57,2.39] (2.39,3.2] ## [37] (2.39,3.2] (2.39,3.2] (2.39,3.2] (2.39,3.2] (1.57,2.39] (1.57,2.39] ## [43] (2.39,3.2] (2.39,3.2] (2.39,3.2] (2.39,3.2] (2.39,3.2] (2.39,3.2] ## [49] (2.39,3.2] (1.57,2.39] (2.39,3.2] (2.39,3.2] (2.39,3.2] (2.39,3.2] ## [55] (2.39,3.2] ## Levels: (1.57,2.39] (2.39,3.2] And, similarly for cut.forhis: nyc.bound$cut.forhis &lt;- cut(nyc.bound$forhis08,breaks=2) nyc.bound$cut.forhis ## [1] (9.63,39.5] (9.63,39.5] (9.63,39.5] (39.5,69.4] (39.5,69.4] (39.5,69.4] ## [7] (39.5,69.4] (9.63,39.5] (39.5,69.4] (39.5,69.4] (39.5,69.4] (39.5,69.4] ## [13] (39.5,69.4] (39.5,69.4] (39.5,69.4] (9.63,39.5] (39.5,69.4] (9.63,39.5] ## [19] (9.63,39.5] (9.63,39.5] (39.5,69.4] (9.63,39.5] (39.5,69.4] (39.5,69.4] ## [25] (39.5,69.4] (9.63,39.5] (39.5,69.4] (9.63,39.5] (9.63,39.5] (39.5,69.4] ## [31] (39.5,69.4] (39.5,69.4] (39.5,69.4] (9.63,39.5] (9.63,39.5] (9.63,39.5] ## [37] (9.63,39.5] (9.63,39.5] (39.5,69.4] (9.63,39.5] (9.63,39.5] (9.63,39.5] ## [43] (9.63,39.5] (9.63,39.5] (9.63,39.5] (9.63,39.5] (39.5,69.4] (39.5,69.4] ## [49] (39.5,69.4] (9.63,39.5] (39.5,69.4] (39.5,69.4] (9.63,39.5] (39.5,69.4] ## [55] (9.63,39.5] ## Levels: (9.63,39.5] (39.5,69.4] The two new factor variables are used as conditioning variables in the by argument of the tm_facets command. The first variable conditions the rows (i.e., is the y-axis), the second variable conditions the columns (i.e., is the x-axis). We illustrate this with the rent2008 variable, using the default map type. Two important options that affect the look of the conditional map are free.coords and drop.units. The default is that each facet map has its own scaling, focused on the relevant observations. Typically, one wants the same spatial layout in each facet, i.e., all the sub-boroughs in our example. This is ensured by setting free.coords=FALSE. In addition, we want all the spatial units to be shown in each facet (the default is to only show those that match the conditions). This is accomplished by setting drop.units=FALSE. The result is as follows: tm_shape(nyc.bound) + tm_fill(&quot;rent2008&quot;) + tm_borders() + tm_facets(by = c(&quot;cut.hhsiz&quot;, &quot;cut.forhis&quot;),free.coords = FALSE,drop.units=FALSE) Cartogram A final map functionality that we replicate from the GeoDa Workbook is the cartogram. GeoDa implements a so-called circular cartogram, where circles represent spatial units and their size is proportional to a specified variable. In R, a useful implementation of different types of cartograms is included in the package cartogram. Specifically, this supports the circular cartogram, as cartogram_dorling, as well as contiguous and non-contiguous cartograms, as, respectively, cartogram_cont and cartogram_ncont. The result of these functions is a simple features layer, which can then be mapped by means of the usual tmap commands. For example, following the GeoDa Workbook, we take the rent2008 variable to construct a circular cartogram. We pass the layer (nyc.bound) and the variable to the cartogram_dorling function. We check that the result is an sf object. carto.dorling &lt;- cartogram_dorling(nyc.bound,&quot;rent2008&quot;) class(carto.dorling) ## [1] &quot;sf&quot; &quot;data.frame&quot; We can now map the cartogram with the usual tmap command. We just use the default settings here, but, obviously, all the customizations we covered before can be applied to the cartogram as well. tm_shape(carto.dorling) + tm_fill(&quot;rent2008&quot;) + tm_borders() As a bonus, we illustrate the contiguous cartogram, which stretches the boundaries such that the spatial units remain contiguous, but take on an area proportional to the variable of interest (the nonlinear algorithm to compute the new boundaries may take a while). Again, the result can be mapped in the usual way. carto.cont &lt;- cartogram_cont(nyc.bound,&quot;rent2008&quot;) ## Mean size error for iteration 1: 2.72610922343519 ## Mean size error for iteration 2: 2.08034510445718 ## Mean size error for iteration 3: 1.71497834119153 ## Mean size error for iteration 4: 1.50262528893195 ## Mean size error for iteration 5: 1.37280555648016 ## Mean size error for iteration 6: 1.29365424163614 ## Mean size error for iteration 7: 1.24063325840562 ## Mean size error for iteration 8: 1.2048990347423 ## Mean size error for iteration 9: 1.18019211993726 ## Mean size error for iteration 10: 1.16217747289098 ## Mean size error for iteration 11: 1.14756915281684 ## Mean size error for iteration 12: 1.13532195567304 ## Mean size error for iteration 13: 1.12488786981234 ## Mean size error for iteration 14: 1.11564793244756 ## Mean size error for iteration 15: 1.10728636377101 tm_shape(carto.cont) + tm_fill(&quot;rent2008&quot;) + tm_borders() And, finally, a non-contiguous cartogram, which has the spatial units floating in space. carto.ncont &lt;- cartogram_ncont(nyc.bound,&quot;rent2008&quot;) tm_shape(carto.ncont) + tm_fill(&quot;rent2008&quot;) + tm_borders() Use setwd(directorypath) to specify the working directory.↩ Use install.packages(packagename).↩ The older function save_tmap has been deprecated.↩ For example, in our first map, the default value for n is 5, but the pretty map that is constructed has 6 categories. Other classifications provide more control over the number of intervals.↩ "],
["rate-mapping.html", "Chapter 5 Rate Mapping Introduction 5.1 Preliminaries 5.2 Choropleth Map for Rates 5.3 Excess risk 5.4 Empirical Bayes Smoothed Rate Map 5.5 EB rate map", " Chapter 5 Rate Mapping Introduction This notebook covers the functionality of the Rate Mapping section of the GeoDa workbook. We refer to that document for details on the methodology, references, etc. The goal of these notes is to approximate as closely as possible the operations carried out using GeoDa by means of a range of R packages. The notes are written with R beginners in mind, more seasoned R users can probably skip most of the comments on data structures and other R particulars. Also, as always in R, there are typically several ways to achieve a specific objective, so what is shown here is just one way that works, but there often are others (that may even be more elegant, work faster, or scale better). For this notebook, we use Cleveland house price data. Our goal in this lab is show how to assign spatial weights based on different distance functions. 5.0.1 Objectives After completing the notebook, you should know how to carry out the following tasks: Obtain a coordinate reference system Create thematic maps for rates Assess extreme value rate values by means of an excess risk map Understand the principle behind shrinkage estimation or smoothing rates Use base R to compute rates with bivariate operations 5.0.1.1 R Packages used sf: To read in the shapefile. tmap: To create various rate maps and build up the necessary custom specifications for the box map classification geodaData: To load the dataset for the notebook. 5.0.1.2 R Commands used Below follows a list of the commands used in this notebook. For further details and a comprehensive list of options, please consult the R documentation. Base R: install.packages, library, setwd, class, str, sf: plot, st_crs, st_set_geometry tmap: tm_shape, tm_fill, tm_borders, tm_layout, tmap_mode, tm_basemap 5.1 Preliminaries 5.1.1 Load packages First, we load all the required packages using the library command. If you don't have some of these in your system, make sure to install them first as well as their dependencies.18 You will get an error message if something is missing. If needed, just install the missing piece and everything will work after that. library(sf) library(tmap) library(geodaData) 5.1.2 geodaData All of the data for the R notebooks is available in the geodaData package. We loaded the library earlier, now to access the individual data sets, we use the double colon notation. This works similar to to accessing a variable with $, in that a drop down menu will appear with a list of the datasets included in the package. For this notebook, we use ohio_lung. ohio_lung &lt;- geodaData::ohio_lung 5.2 Choropleth Map for Rates 5.2.1 Spatially extensive and intensive variables We start our discussion of rate maps by illustrating something we should not be doing. This pertains to the important difference between a spatially extensive and a spatially intensive variable. In many applications that use public health data, we typically have access to a count of events, such as the number of cancer cases (a spatially extensive variable), as well as to the relevant population at risk, which allows for the calculation of a rate (a spatially intensive variable). 5.2.1.1 Setting up the Boxmap option Throughout this notebook, we will be using the boxmap function, created in the previous notebook: Basic Mapping. We won't go into depth on how the function was created, but for this information, check out the Basic Mapping notebook chapter. get.var &lt;- function(vname,df) { # function to extract a variable as a vector out of an sf data frame # arguments: # vname: variable name (as character, in quotes) # df: name of sf data frame # returns: # v: vector with values (without a column name) v &lt;- df[vname] %&gt;% st_set_geometry(NULL) v &lt;- unname(v[,1]) return(v) } boxbreaks &lt;- function(v,mult=1.5) { # break points for box map # arguments: # v: vector with observations # mult: multiplier for IQR (default 1.5) # returns: # bb: vector with 7 break points # compute quartile and fences qv &lt;- unname(quantile(v)) iqr &lt;- qv[4] - qv[2] upfence &lt;- qv[4] + mult * iqr lofence &lt;- qv[2] - mult * iqr # initialize break points vector bb &lt;- vector(mode=&quot;numeric&quot;,length=7) # logic for lower and upper fences if (lofence &lt; qv[1]) { # no lower outliers bb[1] &lt;- lofence bb[2] &lt;- qv[1] } else { bb[2] &lt;- lofence bb[1] &lt;- qv[1] } if (upfence &gt; qv[5]) { # no upper outliers bb[7] &lt;- upfence bb[6] &lt;- qv[5] } else { bb[6] &lt;- upfence bb[7] &lt;- qv[5] } bb[3:5] &lt;- qv[2:4] return(bb) } boxmap &lt;- function(vnam,df,legtitle=NA,mtitle=&quot;Box Map&quot;,mult=1.5){ # box map # arguments: # vnam: variable name (as character, in quotes) # df: simple features polygon layer # legtitle: legend title # mtitle: map title # mult: multiplier for IQR # returns: # a tmap-element (plots a map) var &lt;- get.var(vnam,df) bb &lt;- boxbreaks(var) tm_shape(df) + tm_fill(vnam,title=legtitle,breaks=bb,palette=&quot;-RdBu&quot;, labels = c(&quot;lower outlier&quot;, &quot;&lt; 25%&quot;, &quot;25% - 50%&quot;, &quot;50% - 75%&quot;,&quot;&gt; 75%&quot;, &quot;upper outlier&quot;)) + tm_borders() + tm_layout(title = mtitle, title.position = c(&quot;right&quot;,&quot;bottom&quot;),legend.outside = TRUE, legend.outside.position = &quot;right&quot;) } tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing boxmap(&quot;LFW68&quot;, ohio_lung) + tm_basemap(server=&quot;OpenStreetMap&quot;,alpha=0.5) Anyone familiar with the geography of Ohio will recognize the outliers as the counties with the largest populations, i.e., the metropolitan areas of Cincinnati, Columbus, Cleveland, etc. The labels for these cities in the base layer make this clear. This highlights a major problem with spatially extensive variables like total counts, in that they tend to vary with the size (population) of the areal units. So, everything else being the same, we would expect to have more lung cancer cases in counties with larger populations Instead, we opt for a spatially intensive variable, such as the ratio of the number of cases over the population. More formally, if \\(O_i\\) is the number of cancer cases in area i, and \\(P_i\\) is the corresponding population at risk (in our example, the total number of white females), then the raw or crude rate or proportion follows as: \\[r_i = \\frac{O_i}{P_i}\\] 5.2.1.2 Variance instability The crude rate is an estimator for the unknown underlying risk. In our example, that would be the risk of a white woman to be exposed to lung cancer. The crude rate is an unbiased estimator for the risk, which is a desirable property. However, its variance has an undesirable property, namely \\[Var[r_i] = \\frac{\\pi_i(1-\\pi_i)}{P_i}\\] where \\(\\pi_i\\) is the underlying risk in area i. This implies that the larger the population of an area (\\(P_i\\) in the denominator), the smaller the variance for the estimator, or, in other words, the greater the precision. The flip side of this result is that for areas with sparse populations (small \\(P_i\\)), the estimate for the risk will be imprecise (large variance). Moreover, since the population typically varies across the areas under consideration, the precision of each rate will vary as well. This variance instability needs to somehow be reflected in the map, or corrected for, to avoid a spurious representation of the spatial distribution of the underlying risk. This is the main motivation for smoothing rates, to which we return below. 5.2.2 Raw rate map To compute the raw rate, we just divide the count of events by the population for each county. ohio_lung$raw_rate &lt;- ohio_lung$LFW68 / ohio_lung$POPFW68 We don't need the basemap for the rest of the notebook, so we switch back to plot mode in tmap. This is done with tmap_mode plot. Using the boxmap function from earlier we make a map of the lung cancer counts and the raw population based rates. tmap_mode(&quot;plot&quot;) ## tmap mode set to plotting p1 &lt;- boxmap(&quot;LFW68&quot;, ohio_lung) p2 &lt;- boxmap(&quot;raw_rate&quot;, ohio_lung) p2 With tmap_arrange, we can get a side by side comparison of the two maps. tmap_arrange(p1,p2,ncol = 2) With the adjustment for population, the map becomes more meaningful than just the raw count data. We see different upper outliers and a new spatial distribution after this adjustment. 5.3 Excess risk 5.3.1 Relative risk A commonly used notion in demography and public health analysis is the concept of a standardized mortality rate (SMR), sometimes also referred to as relative risk or excess risk. The idea is to compare the observed mortality rate to a national (or regional) standard. More specifically, the observed number of events is compared to the number of events that would be expected had a reference risk been applied. In most applications, the reference risk is estimated from the aggregate of all the observations under consideration. For example, if we considered all the counties in Ohio, the reference rate would be the sum of all the events over the sum of all the populations at risk. Note that this average is not the average of the county rates. Instead, it is calculated as the ratio of the total sum of all events over the total sum of all populations at risk (e.g., in our example, all the white female deaths in the state over the state white female population). Formally, this is expressed as: \\[\\pi=\\frac{\\Sigma_{i=1}^{i=n}O_i}{\\Sigma_{i=1}^{i=n}P_i}\\] which yields the expected number of events for each area i as: \\[E_i=\\pi*P_i\\] The relative risk then follows as the ratio of the observed number of events (e.g., cancer cases) over the expected number: \\[SMR_i=\\frac{O_i}{E_i}\\] 5.3.2 Excess risk map To calculate the excess risk of each county, we need to do a series of computations first as opposed to GeoDa, which does it automatically. We start by calculating the reference rate, which is just the sum of events over the sum of the population. sum_observed &lt;- sum(ohio_lung$LFW68) sum_population &lt;- sum(ohio_lung$POPFW68) p_i &lt;- sum_observed / sum_population Next we calculate the expected number of events for each county based on the reference rate for the whole state and the population for each county. E_i &lt;- p_i * ohio_lung$POPFW68 Lasty, we divide the actual count by the expected count to get the relative risk rate. This ratio will show us which counties have a higher than expected number of lung cancer cases, and which counties have a lower than expected count. ohio_lung$smr &lt;- ohio_lung$LFW68 / E_i In the excess risk map, blue counties will indicate a risk lower than the state average, or \\(SMR_i &lt; 1\\). Red counties indicate a risk higher than the state average, or \\(SMR_i &gt; 1\\). p1 &lt;- tm_shape(ohio_lung) + tm_fill(&quot;smr&quot;,title=&quot;Excess risk&quot;,breaks=c(-100,.25,.5,1,2,4,1000),labels = c(&quot;&lt;.25&quot;, &quot;.25 - .50&quot;, &quot;.50 - 1.00&quot;,&quot;1.00 - 2.00&quot;, &quot;2.00 - 4.00&quot;, &quot;&gt; 4.00&quot; ), palette = &quot;-RdBu&quot;) + tm_borders() + tm_layout(legend.outside = TRUE, legend.outside.position = &quot;right&quot;) p1 Additionally, we can examine the excess risk rate in the form of a boxmap. The boxmap utilizes the full distribution of the rates to identify outliers, compared to the relative risk map, which identifies them as having a value greater than two. p2 &lt;- boxmap(&quot;smr&quot;,ohio_lung) p2 Here we use tmap_arrange to get a side by side comparison again. tmap_arrange(p1,p2,ncol = 2) 5.4 Empirical Bayes Smoothed Rate Map 5.4.1 Borrowing strength As mentioned in the introduction, rates have an intrinsic variance instability, which may lead to the identification of spurious outliers. In order to correct for this, we can use smoothing approaches (also called shrinkage estimators), which improve on the precision of the crude rate by borrowing strength from the other observations. This idea goes back to the fundamental contributions of James and Stein (the so-called James-Stein paradox), who showed that in some instances biased estimators may have better precision in a mean squared error sense. GeoDa includes three methods to smooth the rates: an Empirical Bayes approach, a spatial averaging approach, and a combination between the two. We will consider the spatial approaches after we discuss distance-based spatial weights. Here, we focus on the Empirical Bayes (EB) method. First, we provide some formal background on the principles behind smoothing and shrinkage estimators. 5.4.2 Bayes law The formal logic behind the idea of smoothing is situated in a Bayesian framework, in which the distribution of a random variable is updated after observing data. The principle behind this is the so-called Bayes Law, which follows from the decomposition of a joint probability (or density) into two conditional probabilities: \\[P[AB] = P[A|B]*P[B] = P[B|A]*P[A]\\] where A and B are random events, and | stands for the conditional probability of one event, given a value for the other. The second equality yields the formal expression of Bayes law as: \\[P[A|B] = \\frac{P[B|A]*P[A]}{P[B]}\\] In most instances in practice, the denominator in this expression can be ignored, and the equality sign is replaced by a proportionality sign: \\[P[A|B]\\propto P[B|A]*P[A]\\] \\[P[\\pi|y]\\propto P[Y|\\pi] * P[\\pi]\\] 5.4.3 The Poisson-Gamma model For each particular estimation problem, we need to specify distributions for the prior and the likelihood in such a way that a proper posterior distribution results. In the context of rate estimation, the standard approach is to specify a Poisson distribution for the observed count of events (conditional upon the risk parameter), and a Gamma distribution for the prior of the risk parameter \\(\\pi\\). This is referred to as the Poisson-Gamma model. In this model, the prior distribution for the (unknown) risk parameter \\(\\pi\\) is \\(Gamma(\\alpha,\\beta)\\), where \\(\\alpha\\) and \\(\\beta\\) are the shape and scale parameters of the Gamma distribution. In terms of the more familiar notions of mean and variance, this implies: \\[E[\\pi] = \\alpha/\\beta\\] and \\[Var[\\pi] = \\alpha/\\beta^2\\] Using standard Bayesian principles, the combination of a Gamma prior for the risk parameter with a Poisson distribution for the count of events (O) yields the posterior distribution as \\(Gamma(O+\\alpha,P + \\beta)\\). The new shape and scale parameters yield the mean and variance of the posterior distribution for the risk parameter as: \\[E[\\pi]= \\frac{O+ \\alpha}{P + \\beta}\\] and \\[Var[\\pi] = \\frac{O + \\alpha}{(P+\\beta)^2}\\] Different values for the \\(\\alpha\\) and \\(\\beta\\) parameters (reflecting more or less precise prior information) will yield smoothed rate estimates from the posterior distribution. In other words, the new risk estimate adjusts the crude rate with parameters from the prior Gamma distribution. 5.4.4 The Empirical Bayes approach In the Empirical Bayes approach, values for \\(\\alpha\\) and \\(\\beta\\) of the prior Gamma distribution are estimated from the actual data. The smoothed rate is then expressed as a weighted average of the crude rate, say r, and the prior estimate, say \\(\\theta\\). The latter is estimated as a reference rate, typically the overall statewide average or some other standard. In essense, the EB technique consists of computing a weighted average between the raw rate for each county and the state average, with weights proportional to the underlying population at risk. Simply put, small counties (i.e., with a small population at risk) will tend to have their rates adjusted considerably, whereas for larger counties the rates will barely change. More formally, the EB estimate for the risk in location i is: \\[\\pi_i^{EB}=w_ir_i + (1-w_i)\\theta\\] In this expression, the weights are: \\[w_i = \\frac{\\sigma^2}{(\\sigma^2 + \\mu/P_i)}\\] with \\(P_i\\) as the population at risk in area i, and \\(\\mu\\) and \\(\\sigma^2\\) as the mean and variance of the prior distribution. In the empirical Bayes approach, the mean \\(\\mu\\) and variance \\(\\sigma^2\\) of the prior (which determine the scale and shape parameters of the Gamma distribution) are estimated from the data. For \\(\\mu\\) this estimate is simply the reference rate(the same reference used in the computation of SMR), \\(\\Sigma_{i=1}^{i=n}O_i/\\Sigma_{i=1}^{i=n}P_i\\). The estimate of the variance is a bit more complex: \\[\\sigma^2=\\frac{\\Sigma_{i=1}^{i=n}P_i(r_i-\\mu)^2}{\\Sigma_{i=1}^{i=n}P_i}-\\frac{\\mu}{\\Sigma_{i=1}^{i=n}P_i/n}\\] While easy to calculate, the estimate for the variance can yield negative values. In such instances, the conventional approach is to set \\(\\sigma^2\\) to zero. As a result, the weight \\(w_i\\) becomes zero, which in essence equates the smoothed rate estimate to the reference rate. 5.5 EB rate map We start by computing all of the necessary parameters for the variance formula above. This includes \\(\\mu\\), n , the crude rate, \\(r_i\\), \\(O_i\\), and \\(P_i\\). mu &lt;- sum(ohio_lung$LFW68) / sum(ohio_lung$POPFW68) O_i &lt;- ohio_lung$LFW68 P_i &lt;- ohio_lung$POPFW68 n &lt;- length(ohio_lung$POPFW68) r_i &lt;- O_i / P_i Next we compute the variance, to similify the code, we compute the top left portion or \\[\\Sigma_{i=1}^{i=n}P_i(r_i-\\mu)^2\\] as top_left, then compute the variance with the next line. top_left &lt;- sum(P_i * (r_i - mu)^2) variance &lt;- top_left / sum(P_i) - mu / sum(P_i / n) Now that we have the variance, we can compute the \\(w_i\\) values. w_i &lt;- variance / (variance + mu/P_i) Here we use the final formula for the smoothed rates. ohio_lung$eb_bayes &lt;- w_i * r_i + (1 - w_i) * mu ohio_lung$eb_bayes ## [1] 1.150783e-04 1.065711e-04 1.079228e-04 1.029445e-04 1.169062e-04 ## [6] 1.025309e-04 9.454283e-05 1.038335e-04 9.849086e-05 1.064611e-04 ## [11] 1.109825e-04 1.096707e-04 1.058050e-04 1.009664e-04 9.588061e-05 ## [16] 1.166735e-04 1.048742e-04 1.143876e-04 1.091126e-04 1.175319e-04 ## [21] 1.069775e-04 1.191585e-04 1.176190e-04 1.068460e-04 1.069400e-04 ## [26] 1.071089e-04 1.036440e-04 1.119544e-04 9.280937e-05 1.153709e-04 ## [31] 1.071074e-04 1.035920e-04 1.026519e-04 1.086969e-04 1.123365e-04 ## [36] 1.143454e-04 1.087786e-04 1.084304e-04 1.023274e-04 1.243397e-04 ## [41] 1.114789e-04 1.228748e-04 1.050183e-04 1.089482e-04 1.063903e-04 ## [46] 1.115513e-04 1.095161e-04 1.037763e-04 1.128505e-04 1.070939e-04 ## [51] 1.158590e-04 1.074788e-04 1.082377e-04 1.179104e-04 1.167411e-04 ## [56] 1.044656e-04 1.010171e-04 1.071996e-04 1.157866e-04 1.041863e-04 ## [61] 9.693106e-05 1.063645e-04 1.130748e-04 1.027615e-04 1.122900e-04 ## [66] 1.070648e-04 1.113361e-04 1.156885e-04 1.024824e-04 1.015521e-04 ## [71] 1.021452e-04 1.035587e-04 1.064004e-04 1.055062e-04 1.074256e-04 ## [76] 1.208589e-04 1.339407e-04 1.122428e-04 1.113038e-04 1.107139e-04 ## [81] 1.089123e-04 1.090464e-04 1.058359e-04 1.048680e-04 1.176496e-04 ## [86] 1.124378e-04 1.147444e-04 9.951653e-05 Lastly, we plot the EB smoothed rates with the boxmap function. boxmap(&quot;eb_bayes&quot;,ohio_lung) In comparison to the box map for the crude rates and the excess rate map, none of the original outliers remain identified as such in the smoothed map. Instead, a new outlier is shown in the very southwestern corner of the state (Hamilton county). Since many of the original outlier counties have small populations at risk (check in the data table), their EB smoothed rates are quite different (lower) from the original. In contrast, Hamilton county is one of the most populous counties (it contains the city of Cincinnati), so that its raw rate is barely adjusted. Because of that, it percolates to the top of the distribution and becomes an outlier. Use install.packages(packagename).↩ "],
["references.html", "References", " References "]
]
